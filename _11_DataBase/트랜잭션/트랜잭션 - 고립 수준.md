# 트랜잭션 고립 수준

## 한 트랜잭션은 읽고, 다른 트랜잭션을 쓸 때 생기는 문제

### 오손 읽기(dirty read)

- 오손 읽기는 읽기 작업을 하는 트랜잭션 1이 쓰기 작업을 하는 트랜잭션 2가 작업한 중간 데이터를 읽기 때문에 생기는 문제다.
- 작업 중인 트랜잭션 2에서 어떠한 이유로 작업을 롤백하게 된다면, 트랜잭션 1은 무효가 된 데이터를 읽게되고 잘못된 결과를 도출한다.

### 반복 불가능 읽기(non-repeatable read)

- 트랜잭션 1이 데이터를 읽고, 트랜잭션 2가 데이터를 갱신하고, 트랜잭션 1이 다시 한 번 데이터를 읽을 때 문제가 발생한다.
- 트랜잭션 1이 처음 데이터를 읽었을 때와 다시 데이터를 읽었을 때의 결과가 다른 문제가 발생한다. 

### 유령 데이터 읽기(phantom read)

- 트랜잭션 1이 데이터를 읽고, `트랜잭션 2가 데이터를 삽입`하고, 트랜잭션 1이 다시 한 번 데이터를 읽을 때 문제가 발생한다. 
- 트랜잭션 1 입장에서 처음 데이터를 읽었을 때는 없던 데이터가 다시 데이터를 읽었을 때 등장하는 문제가 발생한다. 

## 트랜잭션 고립 수준 명령어 

- 읽기만 하는 트랜잭션이 쓰기 트랜잭션에서 작업한 중간 데이터를 읽음으로써 생기는 문제들은 락을 이용하면 해결할 수 있다. 
- 단, 이런 상황을 락으로 막게되면 트랜잭션의 동시 진행 정도를 과도하게 막으므로 DBMS는 락보다 완화된 방식으로 이를 해결하는 방법을 제공하는데 이것이 `트랜잭션 고립 수준 명령어` 이다.
- 트랜잭션 고립 수준 명령어를 사용하여 트랜잭션 간의 고립 수준을 결정할 수 있다.


### Level 0: READ UNCOMMITTED

- 자신의 데이터에 아무런 공유락을 걸지 않는다.
  - 배타락은 갱신손실 문제 때문에 걸어야한다. 
- **다른 트랜잭션에 공유락과 배타락이 걸린 데이터를 읽을 수 있다.** 
- 발생가능 문제점: 오손 읽기, 반복불가능 읽기, 유령데이터 읽기 발생 가능

### Level 1: READ COMMITTED

- 오손 읽기를 방지하기 위해 자신의 데이터를 읽는 동안 공유락을 걸지만 트랜잭션이 끝나기 전에 해지 가능.
- 발생가능 문제점: 반복불가능 읽기, 유령 데이터 읽기  

### Level 2: REPEATABLE READ

- 자신의 데이터에 설정된 공유락과 배타락을 트랜잭션이 끝날 때까지 유지
- 발생가능 문제점: 유령 데이터 읽기 
- 동시성이 낮아 특별한 상황이 아니라면 사용하지 않는 것이 좋다.

### Level 3: SERIALIZABLE

- 실행 중인 트랜잭션을 다른 트랜잭션으로부터 완벽하게 분리
- 데이터 집합에 범위를 지어 잠금을 설정
- 발생가능 문제점: 없음 

---

## 🗣️ 면접 대비

### 두 트랜잭션이 같은 데이터에 접근하려고 한다. 한 트랜잭션은 읽기 작업만 하고 다른 트랜잭션은 쓰기 작업을 한다고 했을 때 어떤 문제가 발생할 수 있을까?

- 읽기만 하는 트랜잭션이 쓰기 트랜잭션에서 작업한 중간 데이터를 읽을 때 문제가 발생한다.
- 오손 읽기, 반복불가능 읽기, 유령데이터 읽기 등의 문제가 발생할 수 있다. 
- 트랜잭션 고립 수준 명령어를 