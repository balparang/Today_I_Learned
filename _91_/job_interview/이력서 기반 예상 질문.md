# Introduce

<details>
    <summary><b>개발 공부를 어떻게 하는지?</b></summary>
</details>

<details>
    <summary><b>읽기 쉬운 코드란?</b></summary>
</details>

<details>
    <summary><b>객체 지향 프로그래밍이란? Vs. 절차지향 프로그래밍?</b></summary>
</details>

<details>
    <summary><b>객체란?</b></summary>
</details>

<details>
    <summary><b>객체 지향 4대 특성</b></summary>
</details>

<details>
    <summary><b>객체 Vs 클래스 Vs. 인스턴스?</b></summary>
</details>

<details>
    <summary><b>SRP란?</b></summary>
</details>

<details>
    <summary><b>SOLID 원칙?</b></summary>
</details>

<details>
    <summary><b>SOLID 원칙 중 적용 시켜본 것 있는지</b></summary>
</details>

# Project

## Shortify

### 구현

---

<details>
    <summary><b>왜 만들었는지?</b></summary>
</details>

<details>
    <summary><b>BASE64 에 대해 설명. 왜 BASE62를 썼는지?</b></summary>

- BASE64
- BASE62

</details>

<details>
    <summary><b>통계 어떻게 구현?</b></summary>
</details>

<details>
    <summary><b>왜 NoSQL말고, MySQL 사용했나?</b></summary>
</details>

<details>
    <summary><b>Java 17을 쓴 이유?</b></summary>
</details>

<details>
    <summary><b>버전별 Garbage Collection?</b></summary>
</details>

<details>
    <summary><b>Junit4 Vs. Junit5?</b></summary>
</details>

<details>
    <summary><b>단위 테스트, 통합 테스트?</b></summary>
</details>

<details>
    <summary><b>테스트 종류?</b></summary>
</details>

<details>
    <summary><b>REST Docs Vs. Swagger?</b></summary>
</details>

<details>
    <summary><b>빈의 순환참조 문제?</b></summary>
</details>

---

<details>
    <summary><b>관리 비용을 줄인다는게 무슨 말인지?</b></summary>
</details>

<details>
    <summary><b>관리 비용을 줄이기 위해 다른 방법은 없었는지?</b></summary>
</details>

---

### HTTP

<details>
    <summary><b>HTTP란?</b></summary>
</details>

<details>
    <summary><b>HTTP 버전별 차이?</b></summary>
</details>

<details>
    <summary><b>RESTful API란?</b></summary>
</details>

<details>
    <summary><b>RESTful 규약을 다 지켜서 개발했는가?</b></summary>
</details>

<details>
    <summary><b>HTTP Referer 설명?</b></summary>
</details>

<details>
    <summary><b>Redirect Vs. Forward?</b></summary>
</details>

<details>
    <summary><b>Redirect, Forward 스프링에서 어떻게 구현하는지?</b></summary>
</details>

---

### 트랜잭션

<details>
    <summary><b>트랜잭션 이란? </b></summary>

- 👉 데이터베이스 내에서 수행되는 작업의 최소 단위
  - 데이터베이스의 무결성(일관성, 정확성)을 유지하며 데이터의 상태를 변화시키는 기능 수행
  - 한 개 이상의 쿼리를 포함해야하며, ACID 규칙을 만족해야함
- 필요한 이유 
  - 여러 작업이 동시에 같은 데이터를 다룰 때, 동시성 문제 등이 발생 가능한 작업들을 서로 분리하는 단위
  - 데이터를 다룰 때, 장애가 일어난다면 복구의 단위가 된다. 
- 특징: 트랜잭션은 전체가 수행(커밋)되거나 또는 전혀 수행되지 않아야한다(롤백).
- 예시
  - A계좌에서 만 원 출금해서, B계좌에 만 원 입금
  - 만 원 출금 후 입금이 안 되면 치명적 오류 👉 트랜잭션은 전체가 수행(커밋)되거나 또는 전혀 수행되지 않아야한다(롤백). 

</details>

<details>
    <summary><b>트랜잭션 성질 </b></summary>

- 트랜잭션 성질
  - 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질
  - 4가지 성질의 앞글자를 따서 ACID원칙이라고도 한다.
- Atomicity(원자성)
  - 트랜잭션에 포함된 작업은 전부 수행되거나, 전부 수행되지 말아야한다(_all or nothing_).
  - 즉, 완료되지 않은 트랜잭션의 중간 과정 상태를 DB에 반영하지 않는다.
    - 출금과 입금을 한 트랜잭션으로 묶었을 경우, 만 원을 출금한 상태에서, 입금하지 않은 상태가 DB에 반영되지 않는다.
- Consistency(일관성)
  - 데이터베이스는 항상 일관된 상태를 유지해야한다.
  - DB에 여러 제약 조건에 맞는 상태를 보장한다.
    - 마이너스 통장을 허락하지 않는다는 제약 조건이 있을 때, 잔액이 음수가 되면 트랜잭션이 종료된다.
    - A계좌에서 출금해서 B계좌에 입금할 경우, 트랜잭션 전후의 A,B 계좌 잔액 총합은 일정하다.
- Isolation(독립성)
  - 둘 이상의 트랜잭션이 동시에 실행될 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.
  - 각 트랜잭션은 다른 트랜잭션의 방해를 받지 않고 독립적으로 수행되어야한다.
    - 구매자의 계좌에서 출금해서 판매자의 계좌에 아직 입금되지 않은 상황에서, 다른 트랜잭션이 이를 조회해서는 안 된다. 
  - 같은 데이터를 동시에 읽고 쓰는 경우, 변경 중인 데이터를 다른 트랜잭션이 사용하는 경우 데이터의 일관성을 훼손할 수 있다.
    - 동시에 수행되는 트랜잭션이 같은 데이터를 갖고 충돌하지 않도록 제어하는 작업이 필요한데, 이를 `동시성 제어`라고 한다. 
    - 동시성 제어보다 완화된 방법으로 트랜잭션 격리 수준에 따라 트랜잭션 상호 간섭을 완화시키는 방법도 있다.
- Durability(지속성)
  - 트랜잭션이 정상적으로 완료된 경우, 결과는 DB에 영구히 반영되어야한다.
    - ex) 한 번 송금이 완료된 후, 은행 시스템에 장애가 생겨도 송금이 성공한 상태로 복구가 가능해야 한다.

👉 ACID는 이론적으로 트랜잭션이 가져야할 원칙이고, 실제로는 성능을 위해서 손실보장이 완화되기도 한다.

- Ref
  - https://www.youtube.com/watch?v=e9PC0sroCzc

</details>

<details>
    <summary><b>트랜잭션 동시성 제어</b></summary>

- 동시성 제어: 트랜잭션이 수행될 때, 일관성을 깨지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능
  - 동시성 제어를 통해, `일관성`과 `독립성`을 보장한다.
- 두 개의 트랜잭션이 한 개의 데이터에 접근할 때, 읽기/쓰기 작업에 따라 발생하는 상황
  - 두 트랜잭션이 모두 `읽기`만 하는 경우
    - 발생하는 문제 없음.
    - 동시 접근 허용
  - 한 트랜잭션은 `읽기`를 하고, 한 트랜잭션은 `쓰기`를 하는 경우
    - `dirty read(오손 읽기)`, `non-repeatable read(반복 불가능 읽기)`, `phantom-read(유령 읽기)` 발생 가능
    - 동시 접근 허용 또는 불가 선택
  - 두 트랜잭션이 모두 `쓰기`를 하는 경우
    - `갱신손실 문제` 발생 가능 (절대 발생해서는 안 되는 문제)
    - 동시 접근 허용 불가(락을 이용)

### 갱신 손실 문제 해결법

- 갱신손실(lost update) 문제란?
  - 두 개의 트랜잭션이 한 데이터에 동시에 접근하여 쓰기 작업을 할 때, 한 트랜잭션의 갱신 작업이 손실되는 문제.
- 갱신 손실 문제를 해결하려면 트랜잭션을 순차대로 실행하면 되지만, 데이터베이스의 `공유`와 `빠른 응답 처리`를 위하여 그럴 수 없다.  
- 락을 이용하여 갱신손실 문제를 해결하고, 트랜잭션을 동시에 수행할 수 있다. 

### 락

- 락의 종류
  - `공유락(LS, shared lock)`: 트랜잭션이 읽기를 할 때 사용하는 락
  - `배타락(LX, exclusive lock)`: 트랜잭션이 읽기/쓰기를 할 때 사용하는 락
- 공유락과 배타락의 사용 규칙
  - 데이터에 락이 걸려있지 않으면 트랜잭션은 데이터에 락을 걸 수 있음.
  - 트랜잭션이 데이터를 읽기만 하는 경우 `공유락` 요청, 읽기/쓰기를 하는 경우 `배타락` 요청
  - 데이터에 `공유락`이 걸린 경우, 다른 트랜잭션의 `공유락` 요청은 허용하고 `배타락`은 허용하지 않음
  - 데이터에 `배타락`이 걸린 경우, 다른 트랜잭션의 `공유락`, `배타락` 모두 허용하지 않음
  - 트랜잭션이 락을 허용받지 못하면 대기 상태(wait)가 됨

### 2차 락킹

- 락을 걸고 해제하는 시점을 2단계로 나누어서 실행하는 기법.
- 락을 걸고 해제하는 사이에 다른 트랜잭션에게 중간 결과를 보임으로써 데이터의 일관성이 깨질 수 있는데, 이를 해결하기 위해 사용
- 확장단계
  - 트랜잭션이 필요한 락을 획득하는 단계. 이 단계에서는 이미 획득한 락을 해제 하지 않음.
- 수축단계
  - 트랜잭션이 락을 해제하는 단계. 이 단계에서는 새로운 락을 획득하지 않음.
- 중간에 락을 해제하지 않게되면서, 트랜잭션의 중간 결과를 노출하지 않게 된다. 👉 데이터 일관성 문제 해결 

</details>

<details>
    <summary><b>데드락</b></summary>

👉 데이터베이스 데드락이란, 여러 트랜잭션이 자신의 데이터에 대하여 락을 획득한 상태에서, 상대방 데이터에 접근하고자 대기할 때, 교차 대기를 하게 되면서 서로 영원히 대기 상태에 빠지는 상태를 말한다. 

### 해결 방법

- 예방 기법
  - 각 트랜잭션이 시작되기 전에 필요한 데이터를 모두 락킹.
  - 락킹 해야하는 데이터가 많다면 사실상 모든 데이터를 락킹한 것과 비슷하므로 트랜잭션의 병행성 보장 어려움. 
- 회피 기법
- 탐지/회복 기법

</details>


<details>
    <summary><b>트랜잭션 격리 수준? </b></summary>

- 한 트랜잭션은 읽기 작업을 하고, 
- 동시성을 높이기위해 락 방법 대신 좀 더 완화된 병행 제어 기법 

- 동시성 제어 보다 완화된 트랜잭션의 상호 간섭을 완화시키는 방법
</details>

<details>
    <summary><b>DBMS 별 격리 수준? </b></summary>

- MySQL 리피테이블 리드
- MySQL 격리 레벨, `MVCC` 알아야함

</details>

<details>
    <summary><b>트랜잭션 전파 수준? </b></summary>

- 트랜잭션 전파
  - 여러 메서드 호출이 한 트랜잭션에 묶이게 하기 위해서 필요


<img width="1233" alt="image" src="https://github.com/haero77/Today-I-Learned/assets/65555299/e0d057b5-4999-4cc6-b44f-c485a799709e">


</details>

<details>
    <summary><b>@Transactional 동작 원리? </b></summary>
</details>

---

### 프록시, AOP

<details>
    <summary><b>AOP?</b></summary>
</details>

<details>
    <summary><b>프록시 AOP?</b></summary>
</details>

<details>
    <summary><b>프록시 패턴이?</b></summary>
</details>

---

### JPA

<details>
    <summary><b>변경 감지?</b></summary>
</details>

<details>
    <summary><b>영속성 컨텍스트?</b></summary>
</details>

<details>
    <summary><b>JPA 프록시?</b></summary>
</details>

---

## 오디고  

### 구현

<details>
    <summary><b>오프셋 기반? 커서 기반?</b></summary>
</details>


### CI/CD

<details>
    <summary><b>CI/CD 과정 설명해달라</b></summary>
</details>

<details>
    <summary><b>CI란? CD란?</b></summary>
</details>

<details>
    <summary><b>NGINX 썼던데 설명해달라</b></summary>
</details>

---

<details>
    <summary><b>N + 1 문제란?</b></summary>
</details>

<details>
    <summary><b>페치 조인?</b></summary>
</details>

<details>
    <summary><b>Java 예외에 대해 설명</b></summary>
</details>

<details>
    <summary><b>@ExceptionHandler 동작원리?</b></summary>
</details>

<details>
    <summary><b>@ControllerAdvice 동작원리?</b></summary>
</details>

---

<details>
    <summary><b>협업하면서 어려웠던 점?</b></summary>

- 회의 시, 회의의 목적이나 서로 다른 이해도를 갖는 경우가 많았음. 
  - 목적, 회의를 통해 얻어야 할

</details>


---

### TEST



# Experience

- 데브코스에서 무엇을 배웠나?

# Education 

- 왜 전공을 바꿨는지(편입 했는지)?
- 특정 전공 평점이 낮은 이유?  


---

출퇴근하고
니가
안힘들회사?
공부 더 할수있는회사?