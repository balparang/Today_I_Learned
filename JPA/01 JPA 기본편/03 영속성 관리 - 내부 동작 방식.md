> **JPA에서 가장 중요한 2가지**
> - 객체와 관계형 데이터베이스 매핑하기 (설계 레벨)
>     - (Object Relational Mapping)
> - 영속성 컨텍스트


<!-- TOC -->
* [3.1 엔티티 매니저 팩토리와 엔티티 매니저](#31-엔티티-매니저-팩토리와-엔티티-매니저)
  * [엔티티 매니저 팩토리](#엔티티-매니저-팩토리)
  * [엔티티 매니저](#엔티티-매니저)
    * [엔티티 매니저가 커넥션을 얻는 시점](#엔티티-매니저가-커넥션을-얻는-시점)
* [3.2 영속성 컨텍스트란?](#32-영속성-컨텍스트란)
  * [엔티티 매니저와 영속성 컨텍스트의 관계](#엔티티-매니저와-영속성-컨텍스트의-관계)
* [3.3 엔티티의 생명주기 (상태)](#33-엔티티의-생명주기-상태)
  * [상태들](#상태들)
    * [비영속 상태](#비영속-상태)
    * [영속 상태](#영속-상태)
    * [준영속](#준영속)
    * [삭제](#삭제)
  * [언제 쿼리가 나가는가?](#언제-쿼리가-나가는가)
* [3.4 영속성 컨텍스트의 특징](#34-영속성-컨텍스트의-특징)
  * [특징들](#특징들)
    * [영속성 컨텍스트와 식별자 값](#영속성-컨텍스트와-식별자-값)
    * [영속성 컨텍스트와 데이터베이스 저장 (언제 데이터베이스에 저장할까?)](#영속성-컨텍스트와-데이터베이스-저장-언제-데이터베이스에-저장할까)
    * [영속성 컨텍스트가 엔티티를 관리함으로써 생기는 이점](#영속성-컨텍스트가-엔티티를-관리함으로써-생기는-이점)
  * [3.4.1 엔티티 조회](#341-엔티티-조회)
    * [1차 캐시](#1차-캐시)
    * [1차 캐시에서 조회](#1차-캐시에서-조회)
    * [데이터베이스에서 조회](#데이터베이스에서-조회)
  * [3.4.2 엔티티 등록](#342-엔티티-등록)
  * [3.4.3 엔티티 수정](#343-엔티티-수정)
  * [](#)
* [3.5 플러시](#35-플러시)
* [3.6 준영속](#36-준영속)
* [3.7 정리](#37-정리)
<!-- TOC -->


<br>

# 3.1 엔티티 매니저 팩토리와 엔티티 매니저

![img_1.png](img/img_1.png)

## 엔티티 매니저 팩토리

- 애플리케이션 내에서 하나만 만들어서 전체에서 공유
- 여러 스레드 동시 접근해도 안전

## 엔티티 매니저

- 스레드마다 생성
- 스레드간에 공유 절대 금지.

### 엔티티 매니저가 커넥션을 얻는 시점

- 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다.
- 예를 들면, 트랜잭션을 시작할 때 커넥션을 획득.

<br>

# 3.2 영속성 컨텍스트란?

- '엔티티를 영구 저장하는 환경'이라는 뜻
- `EntityManager.persist(entity);`
  - DB에 집어넣는다는 것이 아니고, 영속성 컨텍스트에 넣어서 영속화하겠다는 뜻.

<br>

## 엔티티 매니저와 영속성 컨텍스트의 관계

- 영속성 컨텍스트는 논리적인 개념이고, 눈에 보이지 않는다.
- 엔티티 매니저를 통해 영속성 컨텍스트에 접근한다.

<br>

# 3.3 엔티티의 생명주기 (상태)

- 비영속(_new/transient_): 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속(_managed_): 영속성 컨텍스트에 저장된 상태
- 준영속(_detached_): 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(removed): 삭제된 상태

## 상태들

### 비영속 상태

![img_2.png](img/img_2.png)

```java
Member member = new Member(2L, "HelloB");
```

- 단순히 엔티티 객체를 생성한 상태.
- 영속성 컨텍스트나 DB와는 관계 없다.

### 영속 상태

![img_3.png](img/img_3.png)

```java
em.persist(member);
```

- 영속 상태 = 영속성 컨텍스트에 의해 관리되는 상태

### 준영속

```java
em.detach(member);
```

### 삭제

```java
em.remove(member);
```

<br>

## 언제 쿼리가 나가는가?

- **_영속 상태로 만든다고 해서 SQL이 실행되는 것은 아니다._**
- 실제로는 트랜잭션 커밋시에 영속성 컨텍스트에 있던 쿼리가 나가게 된다. 


<br>

# 3.4 영속성 컨텍스트의 특징

## 특징들

### 영속성 컨텍스트와 식별자 값

- 영속성 컨텍스트는 엔티티를 식별자 값(`@Id` 필드)로 구분한다.
- 따라서, _**영속 상태는 식별자 값이 반드시 있어야한다.**_
  - 식별자 값이 없을 시 예외 발생.

### 영속성 컨텍스트와 데이터베이스 저장 (언제 데이터베이스에 저장할까?)

- JPA는 보통 '트랜잭션을 커밋하는 순간' 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영(=**플러시**)

### 영속성 컨텍스트가 엔티티를 관리함으로써 생기는 이점

1. 1차 캐시
2. 동일성 보장
3. 트랜잭션을 지원하는 쓰기 지연
4. 변경 감지
5. 지연 로딩

<br>

## 3.4.1 엔티티 조회

### 1차 캐시

- 1차 캐시: 영속성 컨텍스트가 가지는 내부의 캐시.
- 영속 상태의 엔티티는 모두 1차 캐시에 저장된다.


```java
// 엔티티를 생성한 상태(비영속)
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");

// 엔티티를 영속
em.persist(member);
```

![img.png](img/img2/img.png)

_(영속성 컨텍스트 1차 캐시)_

- 위 코드 실행 시, 1차 캐시에 회원 엔티티를 저장한다.
  - _아직 데이터베이스에 저장된 것은 아니다._
- 1차 캐시의 Key는 **식별자 값**이며, 식별자 값은 데이터베이스의 **기본키**와 매핑되어있다.

### 1차 캐시에서 조회

```java
Member member = em.find(Member.class, "member1")
```

[//]: # (todo 여기부터 다시)

- `em.find()` 호출 시, 우선 1차 캐시에서 식별자 값으로 엔티티를 찾는다.
- 찾는 엔티티가 있으면 데이터베이스를 조회하지 않고 **메모리에 있는 1차 캐시에서 엔티티를 조회**한다.
- 만약 찾는 엔티티가 없으면 데이터베이스에서 조회한다.


### 데이터베이스에서 조회

<br>

## 3.4.2 엔티티 등록

<br>

## 3.4.3 엔티티 수정

<br>

## 

# 3.5 플러시

# 3.6 준영속

# 3.7 정리