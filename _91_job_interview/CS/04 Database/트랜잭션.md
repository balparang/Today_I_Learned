
# ACID 

트랜잭션은 ACID(Atomicity, Consistency, Isolation, Durability)를 보장해야한다.

- 원자성
  - 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하든가 실패해야한다.
  
- 일관성
  - 모든 트랜잭션은 일관성 잇는 뎅이터베이스 상태를 유지해야한다.
  - ex) 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야한다.
  
- 격리성
  - 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다.
    - ex) 동시에 같은 데이터를 수정하지 못하도록 해야 한다. 
  - 격리성은 동시성과 관련된 성능 이슈로 인해 격리 수준 선택 가능
  
- 지속성
  - 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 
  - 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.


<br>

---

# 트랜잭션 격리 수준 

- 트랜잭션은 원자성, 일관성, 지속성을 보장한다. 문제는 격리성이다.
- 격리성을 완벽히 보장하려면 트랜잭션을 거의 순차적으로 실행해야한다.
  - 👉 동시성 처리 성능이 매우 나빠짐
- ANSI에서 트랜잭션의 격리 수준을 4단계로 나누어 정의 

<br>

## 격리 수준 

### READ UNCOMMITTED

- _"`DIRTY READ`를 허용하는 격리 수준"_
- `DIRTY READ` 발생 가능
  - 트랜잭션 1이 데이터를 수정하고 있는데, 커밋하지 않아도 트랜잭션 2가 수정 중인 데이터를 조회할 수 있을 수 있음.
  - 트랜잭션 2가 DIRTY READ한 값을 사용 중인데, 트랜잭션 1을 롤백하면 데이터 정합성 문제 발생 가능.

<br>

### READ COMMITTED

- _"`DIRTY READ`는 허용하지 않지만, `NON-REPEATABLE READ`는 허용하는 격리 수준."_ 
- 커밋한 데이터만 읽을 수 있다. 👉 `DIRTY READ` 해결
- `NON-REPEATABLE READ` 발생 가능
  - **반복해서 같은 데이터를 읽을 수 없는 상태** 
  - 트랜잭션 1이 회원 A를 조회 중인데, 갑자기 트랜잭션 2가 회원 A를 수정하고 커밋하면 트랜잭션 1이 회원을 다시 조회했을 때 수정된 데이터가 조회된다.

<br>

### REPEATABLE READ

- _"`NON-REPEATABLE READ`는 허용하지 않지만, `PHANTOM READ`는 허용하는 격리 수준."_
- **한 번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회됨** 👉`NON-REPEATABLE READ` 해결 
- `PHANTOM READ` 발생 가능 
  - **반복 조회시 결과 집합이 달라지는 현상**  
  - 예시 
    - 트랜잭션 1이 10살 이하의 회원을 조회했는데, 
    - 트랜잭션 2가 5살 회원을 추가하고 커밋하면, 
    - 트랜잭션 1이 다시 10살이하의 회원을 조회했을 때 **회원 하나가 추가된 상태로 조회됨.**

<br>

### SERIALIZABLE

- 가장 엄격한 트랜잭션 격리 수준.
- 인덱스에 공유락을 설정하여 다른 트랜잭션의 INSERT문이 금지됨.
- `PHANTOM READ` 발생하지 않음.
- 동시성 처리 성능이 급격히 떨어질 수 있음.