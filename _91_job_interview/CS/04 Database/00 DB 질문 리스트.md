# Index

<details>
    <summary><b>인덱스 개념, 필요성</b></summary>

### 인덱스

**개요**

<img src="https://velog.velcdn.com/images/balparang/post/4ebf9e54-df43-4442-8b22-a4e1e40cb512/image.png" width="400">

위 같은 테이블에서 age가 20인 행을 찾기 위해서 컴퓨터는 모든 row를 순차적으로 탐색할 것이다. 행이 많아진다면 이런 방식은 많은 시간이 소요될 수 밖에 없다.

<img src="https://velog.velcdn.com/images/balparang/post/68a3af2b-f8d9-43c2-8dea-a8145a848b40/image.png" width="400">

따라서 컬럼을 복제해서 정렬해둔 다음에 이분 탐색으로 빠르게 행을 찾아 나간다.

### 인덱스

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcBQD97%2FbtqKRtpm2pl%2Frmo7jTbiiE9tsSQsUg0JPK%2Fimg.png">

- 인덱스
    - 자료를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조. 책의 색인을 통해 원하는 정보를 빠르게 찾는 것처럼 인덱스도 그와 같은 역할
- 데이터베이스의 Index
    - _**추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조**_
    - 원하는 데이터를 빨리 찾기 위해 **_투플의 키 값에 대한 물리적 위치_** 를 기록해둔 자료구조이다.

### Index를 사용하는 이유

- Table에 데이터를 지속적으로 저장하게 되면 내부적으로 순서 없이 쌓이게 된다.
- 특정 조건을 만족하는 데이터를 찾고자 WHERE절을 사용한다면 Table의 ***튜플을 처음부터 끝까지 모두 접근하여 검색조건과 일치하는지 비교하는 과정(=`Table Full Scan`)*** 이 필요하다.
- 특정 컬럼에 대한 Index를 생성해 놓은 경우 해당 속성에 대하여 `search-key`가 정렬되어 저장되어 있기 때문에 조건 검색(SELECT ~ WHERE) 속도가 굉장히 빠르다.

## Index 구조

- 인덱스는 B Tree, B+Tree, Hash, Bitmap 등으로 구현 가능
    - 일반적인 RDBMS는 B+Tree를 주로 사용
- 인덱스를 생성하면 **_특정 컬럼의 값을 기준으로 정렬하여 물리적 위치와 함께 별도 파일에 저장_** 된다.
    - 리프 노드에는 해당 데이터의 저장 위치에 대응하는 rowID(RID, Row Identify, 테이블의 행에 대한 논리적 위치)를 가지고 있어 찾고자 하는 행을 바로 찾을 수 있다.
- 인덱스에 저장되는 속성 값을 `search-key`값이라고 하고, 실제 데이터의 물리적 위치를 저장한 값을 `pointer` 라고 한다.
- **_인덱스는 순서대로 정렬된 `search-key`값과 `pointer`값만 저장하기 때문에 table 보다 적은 공간을 차지한다._**

### Index의 관리

DBMS는 index를 항상 정렬된 상태를 최신으로 유지해야 원하는 값을 빠르게 탐색 가능. 따라서 `INSERT`, `UPDATE`, `DELETE`문이 수행된다면 다음과 같은 연산이 추가적으로 필요하고 그에 따라 오버헤드가 발생한다.

- `INSERT`: 새로운 데이터에 대한 인덱스를 추가한다.
- `UPDATE`: 기존의 인덱스를 `사용하지 않음`으로 처리하고, 갱신된 데이터에 대해 인덱스를 추가한다.
- `DELETE`: 삭제하는 데이터의 인덱스를 `사용하지 않음`으로 처리


## 인덱스의 장단점

### 장점

- **_최대 장점은 검색 속도 향상(`SELECT~WHERE~`)이다._**
    - 데이터 검색 시 모든 튜플을 순차적으로 검색, 비교하는 `Table Full Scan`을 하지 않고 인덱스에 정렬된 데이터를 통해 빠르게 원하는 튜플에 접근 가능
- SELECT문 외에도 UPDATE문이나 DELETE문의 성능도 함께 향상된다. 해당 연산을 수행하려면 해당 대상을 조회해야만 작업을 할 수 있기 때문
  ```sql
  // 'haero'라는 이름을 업데이트 해주기 위해서는 'haero'를 조회해야 한다.
  UPDATE USER SET NAME = `haero77` WHERE NAME = 'haero';
  ```

### 단점 2가지

1. 추가 저장 공간 필요
- Index를 생성하면 Index 자료구조를 위한 공간이 추가적으로 필요.
- 보통 테이블 크기의 10% 공간을 차지.
2. 느린 데이터 변경 작업
- 검색이 아닌 데이터 변경 작업, 즉 `INSERT`, `UPDATE`, `DELETE`가 자주 발생하면 성능이 나빠질 수 있다.
- 보통 B+Tree 구조의 경우 데이터를 변경할 때마다 트리 구조가 변경될 수 있다. 즉, **_인덱스를 재구성하기 위한 오버헤드가 발생_** 한다.

<br>

# 기타

### 인덱스는 언제 사용하면 좋을까?

- `INSERT`, `UPDATE`, `DELETE가` **_자주 발생하지 않는 컬럼_**
    - 삽입, 수정, 삭제가 빈번한 속성에 인덱스를 걸면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과 발생
    - `UPDATE`와 `DELETE`는 기존의 인덱스를 삭제하지 않고 `사용하지 않음` 처리를 한다.
        - 어떤 테이블에 `UPDATE`, `DELETE`가 자주 발생한다면 실제 데이터는 10만 건이지만, 인덱스는 100만 건이 넘어가므로 SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능 하락 가능성 있음.
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼

### 기본키는 인덱스가 필요없다.

Primary Key의 경우 자동으로 정렬이 되어있기 때문에 굳이 인덱스를 만들 필요 없다. 이것을 `클러스터형 인덱스`라고 한다.

---

**※ Reference**

- [index가 뭔지 설명해보세요 (개발면접시간) - 코딩애플](https://www.youtube.com/watch?v=iNvYsGKelYs)
- [[Database] 인덱스(index)란? - 망나니 개발자](https://mangkyu.tistory.com/96)
- [[MySQL] B-Tree로 인덱스(Index)에 대해 쉽고 완벽하게 이해하기 - 망나니개발자](https://mangkyu.tistory.com/286)

---

### 추가적으로 공부해 볼 것

- 왜 JOIN절에 인덱스를 사용하는 것이 좋을까?
- 인덱스 Random Access

---

</details> 

<details>
    <summary><b>인덱스를 어느 column에 사용할까</b></summary> 

## ⭐️⭐️ 인덱스를 어느 컬럼에 사용하는 것이 좋을까?

- 인덱스는 `WHERE` 절에서 ***자주 조회되고, 수정 빈도가 낮으며, 카디널리티는 높고, 선택도가 낮은 컬럼***을 선택해서 설정하는 것이 가장 좋다.

| 기준                 | 적합성                          |
|--------------------|------------------------------|
| 카디널리티(Cardinality) | 높을수록 적합(데이터 중복이 적을수록 적합)     |
| 선택도(Selectivity)   | 낮을수록 적합                      |
| 조회 활용도             | 높을수록 적합(WHERE절에서 많이 사용되면 적합) |
| 수정 빈도              | 낮을 수록 적합                     |

> 💡 `카디널리티`란?
>   - ***데이터가 중복되지 않는 정도***를 뜻한다. 데이터가 중복되지 않을수록 카디널리티가 높다.
>   - 예) 주민등록번호는 중복되는 값이 없으므로 카디널리티가 높다.
>   - 예) 성별의 경우 [Male/Female] 값이 중복되어 카디널리티가 낮다.

> 💡 `선택도`란?
>   - ***데이터에서 특정 값을 잘 골라낼 수 있는 정도***를 뜻한다.
>   - 선택도가 1이면 모든 데이터가 unique함을 의미한다.

### Index를 효과적으로 사용하는 방법

- SELECT WHERE 절에 자주 사용되는 컬럼에 대해 인덱스르 생성하는 것이 좋다.
    - 인덱스는 `SELECT~ WHERE~` 절에서 검색 성능을 향상시키기 위해서 사용한다. 따라서 조회가 발생하지 않으면 인덱스를 사용할 필요가 없다.
- 데이터 수정 빈도가 낮을수록 적합하다.
    - `INSERT`, `UPDATE`, `DELETE` 작업 시 데이터에 변화가 생기므로 인덱스를 재구성하는 오버헤드가 발생한다.
- 데이터 중복이 적은 컬럼에 사용하자
    - 데이터 중복이 많은 컬럼은 인덱스 효과가 별로 없다.
    - 성별의 경우 종류가 Male, Female 두 가지 밖에 없으므로 인덱스를 생성하지 않는 것이 좋다.
    - `선택도(Selectivity)`가 낮을 때 유리(보통 5~10% 이내).
        - ~~🤔 데이터가 이미 잘 골라진다면 인덱스를 사용해서 얻는 효과가 미미하므로?~~
- 데이터의 양이 많을 수록 인덱스로 인한 성능향상이 더 크다.
    - 데이터가 10개 밖에 되지 않으면 `Full Table Scan` 시간이 얼마 걸리지 않는다. 이런 경우 굳이 인덱스를 사용할 필요가 없다.
    - 데이터의 양이 적다면 index의 혜택보단 손해가 더 클 수 있다.
- Join 조건으로 자주 사용되는 컬럼의 경우
- 한 테이블에 인덱스가 너무 많으면 데이터 수정 시 소요되는 시간이 너무 길어질 수 있다. (테이블 당 4~5개 정도 권)

</details> 

<details>
    <summary><b>인덱스의 자료구조</b></summary> 

# 인덱스의 자료구조

## Hash Table

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FRpMoO%2FbtqKMzdg9TX%2FXYkGt2kqE0hr9rqhHx3o3K%2Fimg.png)

- `해시 테이블`: `Key-Value` 구조로 데이터를 저장하고 빠른 데이터 검색이 필요할 때 유용하다.
- 해시 테이블 기반의 DB 인덱스는 컬럼의 값을 Key로, 데이터의 위치를 Value로 사용하여 컬럼의 값으로 생성된 해시를 통해 인덱스를 구현

### Hash Index가 DB의 Index 구조로 적합하지 않은 이유

- Hash Index는 데이터 검색시 시간복잡도가 O(1)이므로, 데이터 검색 시 속도가 빠르다.
- 단, ***Hash Index의 경우 등호(`=`)연산에만 특화되었으므로, DB 인덱스에서 사용하기에는 제한적***이다.
- _**데이터가 조금이라도 달라지면 Hash Function은 다른 Hash값을 생성하므로, 부등호 연산(>, <)이 자주 사용되는 DB 검색에선는 Hash Index 가 적합하지 않다.**_
- 예) "나는"으로 시작하는 모든 데이터를 검색하기 위한 쿼리문은 인덱스의 혜택을 전혀 받지 못한다. 따라서 일반적으로 DBMS는 `B+Tree` 자료구조를 이용한다.

# B+Tree Index

### BST

<img src="https://velog.velcdn.com/images/balparang/post/dccce2c7-d551-4c48-b6a1-9a935b0e3f25/image.png" width="500">

### B Tree (B 트리)

<img src="https://velog.velcdn.com/images/balparang/post/0ae593cc-1541-479c-81fc-7a139c8fa418/image.png" width="500">

- BST 구조에서 노드마다 데이터를 2개 이상 저장하여 검색 속도를 강화
- BST 에서는 2번의 이동으로 1~7 이동 가능했지만 B-Tree를 이용하여 두 번의 이동으로 1~13 검색이 가능해졌다.

## B+Tree

<img src="https://velog.velcdn.com/images/balparang/post/12b5d094-5a4c-4d53-a149-bb990ffc5243/image.png" width="500">

<img src="https://velog.velcdn.com/images/balparang/post/0c36112b-1c74-4f73-b1d9-5f8515ce9192/image.png" width="500">

- DB의 인덱스를 위해 **_자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조._**

> 참고) B+Tree의 B는 Balance!

### B+Tree가 DB Index를 위한 자료구조로 적합한 이유

1. **_항상 정렬된 상태를 유지하여 부등호 연산에 유리하다._**
2. 데이터 탐색뿐 아니라, 삽입/수정/삭제 시에도 항상 O(logN)의 시간 복잡도를 갖는다.

<img src="https://velog.velcdn.com/images/balparang/post/ed1f3105-d35f-4c6a-8995-391a71cbbe4d/image.png">

`박현지`보다 작은 값들을 가리키는 포인터를 저장 & `박현지`보다 크거나 같은 값들을 가리키는 포인터를 저장

### B+Tree 실제 구조

<img src="https://velog.velcdn.com/images/balparang/post/364b227f-7c26-43f5-808e-405938ee0f80/image.png">

- 리프노드만 데이터를 갖는다. 리프노드가 아닌 노드는 데이터가 아니라 어디로 이동해야할지 가이드(=포인터)만 갖는다.
- 리프노드에는 데이터들이 `search-key`를 기준으로 정렬되어있다.
- _**리프노드는 LinkedList로 연결되어 범위 검색이 쉬워진다.**_
    - B-Tree 의 경우 범위를 벗어나는 데이터를 검색할 경우 상위 노드로 이동해서 데이터가 있는 노드로 이동해야한다.
    - B+Tree는 데이터 노드의 범위를 벗어나는 데이터를 검색할 경우 상위 노드로 이동하지 않고 다음 데이터 노드로 이동하면 된다.
- 부등호가 있는 `SELECT WHERE` 절 동작 예시
    - `SELECT * FROM STUDENT WHERE 이름 >= '배준석';` 실행
    - 루트노드 `박현지` 로 이동
    - `배준석`이 비교대상 `박현지`보다 크므로 오른쪽 포인터 타고 뎁스가 1인 노드로 이동
    - `배준석`이 비교대상 `정재헌`보다 작으므로 왼쪽 포인터 타고 리프노드로 이동
    - 이름이 `배준석` 이상인 데이터를 SELECT

---

**※ Reference**

- [index가 뭔지 설명해보세요 (개발면접시간) - 코딩애플](https://www.youtube.com/watch?v=iNvYsGKelYs)
- [[Database] 인덱스(index)란? - 망나니 개발자](https://mangkyu.tistory.com/96)
- [[MySQL] B-Tree로 인덱스(Index)에 대해 쉽고 완벽하게 이해하기 - 망나니개발자](https://mangkyu.tistory.com/286)

</details> 

<details>
    <summary><b>인덱스는 왜 hash table이 아니라 b+tree로 구현되었을까</b></summary>


### 🆀 데이터를 검색을 할 때 해시 테이블의 시간복잡도는 O(1)이고 B+Tree는 O(logN)으로 더 느린데 왜 인덱스는 해시 테이블이 아니라 B+Tree로 구현되었을까요?

- Hash Index의 경우 등호연산에만 특화되어있다.
- 조금이라도 다른 데이터에 대해서 다른 해시값을 가지므로, 부등호 연산이 많은 DB검색에는 적합하지 않다.
- B+Tree 의 경우 데이터가 저장되는 리프노드가 LinkedList로 연결되어있다. 따라서 범위 검색시 다음 리프노드로 바로 이동할 수 있다.
    - 즉, 부등호 연산이 많은 DB검색에 적합하다.


</details> 

---

## Clustered Index Vs. Non-Clustered Index

<details>
    <summary><b>Clustered Index </b></summary> 


## 클러스터형 인덱스(Clustering Index)

- **_특정 컬럼을 기본키로 지정하면 자동으로 클러스터형 인덱스가 생성_** 되고, 해당 컬럼을 기준으로 정렬된다.
- 즉, **_원본 Table 자체가 정렬된 하나의 Index인 것_**(영어사전처럼 책 내용 자체가 정렬된 것이라고 생각하면 된다.)
- 테이블 당 하나만 생성 가능
- PK 기준으로 인덱스도 정렬되어있다.
- 테이블 생성시 PK를 지정하면 클러스터 인덱스 생성
    - 이미 생성된 테이블에서 특정 컬럼을 PK로 지정하는 경우 일반적으로 RDBMS 시스템은 해당 컬럼에 대한 인덱스를 만드는데, 이 인덱스는 클러스터 인덱스가 아닌 `Secondary Index`이다.
        - [인프런 - 질문과답변: 클러스터링이 별도로 인덱스가 생성되는 것인지 헷갈립니다.](https://www.inflearn.com/questions/853149/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81%EC%9D%B4-%EB%B3%84%EB%8F%84%EB%A1%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EA%B0%80-%EC%83%9D%EC%84%B1%EB%90%98%EB%8A%94-%EA%B2%83%EC%9D%B8%EC%A7%80-%ED%97%B7%EA%B0%88%EB%A6%BD%EB%8B%88%EB%8B%A4)

<img src="https://velog.velcdn.com/images/balparang/post/b1222c7a-79a4-4c6d-93fe-635f9384d242/image.png">

<img src="https://velog.velcdn.com/images/balparang/post/4857ee7e-2be8-4499-af56-fc0b23ce97d9/image.png">

</details>

<details>
    <summary><b>Non-Clustered Index</b></summary> 


## 보조형 인덱스(Secondary Index)

- 일반 책의 `색인`과 같이 **_별도의 공간에 Index가 생성_** 된다.
- `create index`와 같이 '인덱스 생성하기'를 하거나, 고유키(`unique key`)로 지정하면 보조 인덱스가 생성된다.

<img src="https://velog.velcdn.com/images/balparang/post/766878dc-82a2-4954-93f3-50600f0a9c22/image.png">

위는 `CREATE INDEX idx_name ON STUDENT(이름)` 에 의해 생성된 보조형 인덱스이다.

- 인덱스의 `search-key`가 'ㄱ-ㅎ'순으로 정렬되고, `pointer`는 튜플의 물리적 위치가 저장된다.
- Secondary Index는 실제로 포인터를 저장하지 않는다. (PK를 참조한다.)


<br>

> 👉 `클러스터형 인덱스`는 **_테이블에 저장된 데이터 자체를 정렬_** 하는 것이고, `보조형 인덱스`는 **_테이블은 건드리지 않으면서 추가적으로 인덱스만 따로 생성하는 것._**
> 테이블이 search-key 를 기준으로 정렬이 되어있으면 클러스터 인덱스, 정렬이 안 되어 있으면 Secondary Index

- Clustered Index는 하나의 컬럼을 기준으로 Data Page 자체를 정렬하기 때문에 테이블 당 하나밖에 생성하지 못한다는 것입니다.

이때 Non-Clustered Index로 문제를 해결할 수 있습니다. 다

---
**※ Reference**

- [기출로 대비하는 개발자 전공면접 [CS 완전정복]](https://www.inflearn.com/course/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%A0%84%EA%B3%B5%EB%A9%B4%EC%A0%91-cs-%EC%99%84%EC%A0%84%EC%A0%95%EB%B3%B5/dashboard)
- [[MySQL] 인덱스(index), 클러스터/보조인덱스 - 실행계획 포함](https://jie0025.tistory.com/107)
- [[MYSQL] 📚 인덱스(index) 핵심 설계 & 사용 문법 💯 총정리 - 인테이블당](https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%9D%B8%EB%8D%B1%EC%8A%A4index-%ED%95%B5%EC%8B%AC-%EC%84%A4%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC)

</details>

<br>

---


# 트랜잭션

- 트랜잭션
- ACID

## 동시성  

- 동시성 문제
- 데드락 
- 트랜잭션 격리 수준
- 트랜잭션 전파⭐️ 

# 정규화

<br>

---

# Key

<br>

---

# Join

<br>

---

<details>
    <summary><b>Join</b></summary> 

### 조인

- 조인(Join): 두 테이블의 공통 컬럼을 기준으로 컬럼 값이 같은 튜플을 수평으로 결합하는 연산
- 두 테이블을 카티전 프로덕트 연산 후 셀렉션 연산을 한 것으로 정의할 수 있다.

- 기본 조인 연산
    - 세타조인
    - 동등조인
    - 자연조인
- 확장된 조인 연산
    - 세미조인
    - 외부조인

## 조인 종류

### 세타조인

- 조인에 참여하는 두 릴레이션의 속성값을 비교하여 조건을 만족하는 투플만 반환
- 세타조인의 '조건': {=, !=, <=, >=, <, >} 중 하나

### 동등조인(=내부조인. inner join)

- 세타조인에서 `=` 연산자를 사용한 조인
- 주로 한 테이블의 기본키와 다른 테이블의 외래키가 같을 때를 조건으로 조인 연산을 수행

### 자연조인

- 동등조인(내부조인)에서 조인에 참여한 속성이 두 번 나오지 않도록 두 번째 속성을 제거한 결과를 반환

### 외부조인

- 자연조인 시 자연 조인에 실패한 투플을 모두 보여주되 _**값이 없는 속성에는 널 값을 채워 반환**_.

### 세미조인

- 자연조인을 한 후 두 릴레이션 중 한쪽 릴레이션의 결과만 반환
- 기호에서 닫힌 쪽 릴레이션의 투플만 반환
    - R ⋉ S: R쪽 릴레이션의 투플만 반환

</details>

<details>
    <summary><b>inner join Vs. left outer join</b></summary> 

- Join 이란 두 개 이상의 테이블을 서로 연결하여 하나의 결과를 만들어 보여주는 것
- inner join 은 두 테이블에 모두 있는 내용만 join되는 방식
- left outer join 은 왼쪽 테이블의 모든 행에 대해서 join 진행
    - 왼쪽 테이블에만 있고 오른쪽 테이블에는 없는 튜플에 대해서는 컬럼값을 null로 표현

<img src="https://velog.velcdn.com/images/balparang/post/51006d45-4ceb-4bce-b974-fbd6c80541fa/image.png" width="500">

</details>