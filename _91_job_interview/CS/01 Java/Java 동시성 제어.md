
<details>
    <summary><b>자바의 Synchronized 키워드를 설명해주세요.</b></summary> 

> 👉 자바의 synchronized 키워드는 하나의 자원에 여러 스레드가 동시에 접근하여 사용할 때 발생할 수 있는 오류를 방지하기 위한 키워드입니다. 현재 데이터를 사용하고 있는 스레드를 제외한 다른 스레드는 데이터에 접근할 수 없게 막는 기술입니다. 메서드나 블럭단위에 지정할 수 있으며 메서드 단위로 지정할 경우 메서드 전체에 lock 이 걸리므로 블럭단위로 지정하는 것이 성능상 유리한 면이 있습니다.

</details>

<details>
    <summary><b>동기화와 비동기화의 차이를 설명해주세요.</b></summary>

> 👉두 방식의 차이점은 ***호출하는 함수가 호출되는 함수의 작업 완료 여부를 신경쓰는지에 대한 여부***에 있습니다. `동기` 방식은 함수 A가 B를 호출한 뒤, 함수 B의 작업 완료 여부를 계속 확인하면서 신경 쓰는 방식입니다. `비동기` 방식은 함수 A가 B를 호출하고 나서, 함수 B의 작업 완료 여부는 신경쓰지 않습니다. B의 작업 완료 여부는 오로지 B만 신경쓰며, 작업이 완료될 경우 콜백함수를 통해 결과를 전달하는 방식이 비동기 방식입니다.

💡 동기와 비동기는 ***순서와 결과처리의 관점***이 핵심

### Sync(동기)
- **_함수 A가 B를 호출한 뒤, 함수 B의 결과값이 나오면 해당 결과값을 바로 처리하는 방식_**
- Java 에서 `Synchronized` 키워드 사용
    - 자바에서 멀티 스레드 접근 제한 키워드
    - 메서드, 블럭 단위 적용 가능
        - 단, ***메서드 단위로 적용할 경우 메서드 전체에 lock이 걸리므로 블럭을 활용***하는 것이 좋다. (임계 영역은 작을 수록 좋다.)

### Async(비동기)
- _**함수 A가 B를 호출하고나서, 함수 B의 작업 완료여부에는 신경쓰지 않는다. 결과가 나오면 처리할 수도 있고 안 할 수도 있다.**_
- Callback 함수를 통해 결과 확인
- ex. Thread

### 🆀 Blocking vs Non-Blocking

👉 처리되어야 하는 (하나의) 작업이 전체적인 작업 `흐름`을 막느냐 안 막느냐에 대한 관점

👉 `제어권`이 누구한테 있느냐가 관심사

- **Blocking**
    - 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 다른 작업이 **_끝날때까지 기다렸다가_** 자신의 작업을 시작하는 것
- **Non-Blocking**
    - 다른 주체의 작업에 관련없이 자신의 작업을 하는 것

**※ Ref**

- [[10분 테코톡] 🐰 멍토의 Blocking vs Non-Blocking, Sync vs Async](https://www.youtube.com/watch?v=oEIoqGd-Sns)
- [인파 - 동기비동기-블로킹논블로킹-개념-정리](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC#%EB%B8%94%EB%A1%9C%ED%82%B9__%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9)

</details>

<details>
    <summary><b>동시성 문제가 무엇인가요? 자바에서 동시성 문제를 해결할 수 있는 방법이 있을까요?</b></summary> 

> 👉 여러 쓰레드가 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 문제를 동시성 문제라고 합니다. 예를 들어, 한 쓰레드에서 필드를 조회하는 도중에 다른 쓰레드가 필드값을 변경하면, 원래의 스레드는 조회만 했을 뿐인데 값이 변경되는 결과를 얻게됩니다. synchronized, volatile, atomic 등을 활용하여 해결할 수 있으며, 쓰레드 별로 변수 값을 다르게 가져가고자 할 때는 Thread Local의 사용 또한 고려해볼 수 있습니다.

### 동시성 문제

- _**여러 쓰레드가 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 문제**_
- 이런 동시성 문제는 여러 쓰레드가 같은 인스턴스의 필드에 접근해야하기 때문에 트래픽이 적은 상황에서는 잘 발생하지 않고, 트래픽이 점점 많아질 수록 자주 발생
    - 스프링 빈처럼 싱글톤 객체의 필드를 변경하여 사용할 때 이러한 동시성 문제를 조심해야 한다.
- _**동시성 문제는 지역 변수에서는 발생하지 않는다.**_
    - 지역 변수는 쓰레드마다 각각 다른 스택 메모리에 할당되기 때문.
- 싱글톤 객체의 필드를 사용하면서 동시성 문제를 해결하는 방법 👉`쓰레드 로컬`
- concurrent 자료구조를 사용하여 해결

**※ 쓰레드(Thread)란?**

- 프로세스 실행의 단위
- 하나의 프로세스는 여러개의 쓰레드로 구성 가능
    - 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 쓰레드를 동시에 실행할 수 있다.
- 하나의 프로세스를 구성하는 쓰레드 들은 프로세스에 할당된 메모리, 자원 등을 공유한다.

참고: [goodgid - what is thread](https://goodgid.github.io/What-is-Thread/)

</details>

<details>
    <summary><b>Thread Local에 대해 설명해주세요.</b></summary> 

> 👉 Thread Local은 싱글톤 객체의 필드를 사용하면서 발생하는 동시성 문제를 해결하는 방법으로, 각 쓰레드마다 접근할 수 있는 별도의 저장소를 제공합니다. 이를 통해 같은 인스턴스의 쓰레드 로컬 필드(`Thread<T> threadVariable`)에 접근해도 동시성 문제가 발생하지 않습니다.

### Thread Local

- 해당 쓰레드만 접근할 수 있는 특별한 저장소를 의미
- 쓰레드 로컬을 사용하면 각 쓰레드마다 별도의 내부 저장소를 제공  👉 **_같은 인스턴스의 쓰레드 로컬 필드에 접근해도 문제 없다._**
- 자바는 언어차원에서 쓰레드 로컬을 지원하기 위해 `java.lang.ThreadLocal` 클래스를 제공한다.
- 주의점
    - 요청이 끝나고 `ThreadLocal.remove()`를 통해서 꼭 제거 해야한다.
    - 제거하지 않았을 경우, 쓰레드 풀에 의해 다른 사용자가 기존 사용자가 사용했던 쓰레드를 사용하는 경우 예상치 못한 값을 사용하게 된다.
- 동작 원리

  ![image](https://user-images.githubusercontent.com/65555299/230367260-d5c2d2d0-4d76-441d-8136-f8977d1630bf.png)
  ![image](https://user-images.githubusercontent.com/65555299/230367329-9af15207-63d7-4739-b479-f48d2a50698a.png)
  ![image](https://user-images.githubusercontent.com/65555299/230367358-084c4cc3-7132-49c9-b25a-5aa47f21c505.png)

  (자료 출처 - 영한님 스프링 고급편)


</details>

<details>
    <summary><b>동기 Vs. 비동기?</b></summary>
</details>

<details>
    <summary><b>Blocking Vs. Non-Blocking?</b></summary>
</details>
