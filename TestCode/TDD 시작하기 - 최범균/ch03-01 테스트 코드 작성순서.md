<!-- TOC -->
* [테스트 코드 작성 순서](#테스트-코드-작성-순서)
  * [쉽거나 예외적인 상황부터](#쉽거나-예외적인-상황부터-)
* [초반에 복잡한 테스트부터 시작하면 안 되는 이유](#초반에-복잡한-테스트부터-시작하면-안-되는-이유)
* [구현하기 쉬운 테스트부터 시작하기](#구현하기-쉬운-테스트부터-시작하기)
  * [암호 검사기 예제](#암호-검사기-예제)
* [3.예외 상황을 먼저 테스트 해야하는 이유](#3예외-상황을-먼저-테스트-해야하는-이유)
* [4. 완급 조절](#4-완급-조절)
  * [뻔한 구현이더라도 단계를 거쳐서 연습하라](#뻔한-구현이더라도-단계를-거쳐서-연습하라)
    * [TDD 연습 방법](#tdd-연습-방법)
* [5. 지속적인 리팩토링 ⭐️](#5-지속적인-리팩토링-)
  * [TDD 과정에서의 지속적인 리팩토링](#tdd-과정에서의-지속적인-리팩토링)
  * [테스트 대상 코드의 리팩토링 시점](#테스트-대상-코드의-리팩토링-시점)
    * [작은 리팩토링은 발견하면 바로 실행](#작은-리팩토링은-발견하면-바로-실행)
    * [메서드 추출과 같은 리팩토링은 신중하게 ⭐️](#메서드-추출과-같은-리팩토링은-신중하게-)
* [2. 테스트 작성 순서 연습](#2-테스트-작성-순서-연습)
  * [쉬운 것부터 테스트](#쉬운-것부터-테스트)
    * [⭐ 테스트를 추가할 때 고려해야하는 두 가지](#-테스트를-추가할-때-고려해야하는-두-가지)
  * [예를 추가하면서 구현을 일반화](#예를-추가하면서-구현을-일반화)
  * [코드 정리: 중복 제거](#코드-정리-중복-제거)
  * [예외 상황 처리](#예외-상황-처리)
  * [다음 테스트 선택: 다시 예외 상황](#다음-테스트-선택-다시-예외-상황)
  * [다음 테스트를 추가하기 전에 리팩토링](#다음-테스트를-추가하기-전에-리팩토링)
  * [예외 상황 테스트 진행 계속](#예외-상황-테스트-진행-계속)
  * [코드 정리: 상수를 변수로](#코드-정리-상수를-변수로)
  * [다음 테스트 선택: 쉬운 테스트](#다음-테스트-선택-쉬운-테스트)
  * [코드 정리](#코드-정리)
  * [다음 테스트: 10개월 요금을 납부하면 1년 제공](#다음-테스트-10개월-요금을-납부하면-1년-제공)
* [3. 테스트할 목록 정리하기](#3-테스트할-목록-정리하기)
* [4. 시작이 안 될 때는 단언부터 고민](#4-시작이-안-될-때는-단언부터-고민)
* [5. 구현이 막히면](#5-구현이-막히면)
<!-- TOC -->

# 테스트 코드 작성 순서

## 쉽거나 예외적인 상황부터 

- 첫 번째 테스트는 가장 쉽거나 가장 예외적인 상황을 선택.
- TDD로 테스트 작성 순서는,
  - 쉬운 경우에서 어려운 경우로 진행
  - 예외적인 경우에서 정상인 경우로 진행

---

# 초반에 복잡한 테스트부터 시작하면 안 되는 이유

- 초반부터 다양한 조합을 검사하는 복잡한 상황을 테스트 하게 되면, 많은 구현을 해야한다.
- 많은 코드를 만들게 되면, 버그 가능성이 높아지고, 이 버그를 잡기 위해 많은 시간을 쓰게 된다. 
  - 당연히 테스트 통과 시간도 길어지고, 코드 작성 시간이 길어지면 집중력도 떨어져서 흐름이 자주 끊긴다.
  - _(테스트-구현-리팩토링 흐름이 끊긴다는 얘기)_

---

# 구현하기 쉬운 테스트부터 시작하기

- 가장 구현하기 쉬운 경우부터 시작하면 빠르게 테스트 통과가 가능하다.
  - 수 분에서 십여 분 이내에 구현을 완료해서 테스트를 통과시킬 수 있을 만큼 쉬운 것을 선택하자 

## 암호 검사기 예제

암호검사기 예제에서 위 경우에 해당하는 경우는,

- 모든 조건을 충족하는 경우 👈 둘 중 차이가 없어서 이것을 선택
- 모든 조건을 충족하지 않는 경우

그 다음 선택할만한 테스트는

- 모든 규칙을 충족하지 않는 경우,
- 한 규칙만 충족하는 경우
- 두 규칙만 충족하는 경우

이렇게 있는데, `모든 조건을 충족하는 경우`에 대한 테스트를 짠 뒤, <br>
`모든 규칙을 충족하지 않는 경우`에 대한 테스트를 짜려면 사실상 구현을 전부 다해야한다.

따라서, `한 규칙만 충족하는 경우` 또는 `두 규칙만 충족하는 경우`를 선택해서 구현하자. 


---

# 3.예외 상황을 먼저 테스트 해야하는 이유



# 4. 완급 조절

## 뻔한 구현이더라도 단계를 거쳐서 연습하라

### TDD 연습 방법

1. 정해진 값을 리턴
2. 

# 5. 지속적인 리팩토링 ⭐️

## TDD 과정에서의 지속적인 리팩토링

<br>

## 테스트 대상 코드의 리팩토링 시점

### 작은 리팩토링은 발견하면 바로 실행

테스트 대상 코드에서,

- 상수를 변수로 바꾸거나,
- 변수 이름을 변경하는 것 등

의 **작은 리팩토링은 발견하면 바로 실행**. 

<br>

### 메서드 추출과 같은 리팩토링은 신중하게 ⭐️

> 구조 잘못 잡음 -> 다음 테스트 시 코드 복잡성 증대, 구현 어려움 

- 구현 초기에는 구현의 전반적인 흐름을 모른다.
  - 즉, 구현 초기에 메서드 추출 같은 리팩토링을 하게 되면 코드 구조를 잘못 잡을 가능성이 있다.
- 코드 구조를 잘못 잡게되면,
  - 👉 다음 테스트를 통과시키는 과정에서 코드가 복잡해지거나, 구현이 막힐 가능성이 있다.
- 이런 상황이 오면 **구현을 멈추고 메서드 추출 리팩토링을 되돌려야한다!**
  - 리팩토링을 취소해서 코드 원상 복구 후 테스트 진행 -> 그 뒤에 코드 구조가 명확해지면 다시 리팩토링 시도

---

# 2. 테스트 작성 순서 연습: 만료일 계산기

예제: 만료일 계산기

```text
- 서비스를 사용하려면 매달 1만원을 선불로 납부한다. 
  - 납부일 기준으로 한 달 뒤가 서비스 만료일이 된다.
- 2개월 이상 요금을 납부할 수 있다.
- 10만원을 납부하면 서비스를 1년 제공한다.
```

- 납부한 금액 기준으로 서비스 만료일을 계산하는 기능을 TDD로 구현하자 

## 쉬운 것부터 테스트

###  ⭐ 테스트를 추가할 때 고려해야하는 두 가지

- **구현하기 쉬운 것부터 먼저 테스트**
- **예외 상황을 먼저 테스트**

### 구현하기 쉬운 것을 테스트

- 만료일 계산기에서는 1만 원 납부 시 한 달 뒤 같은 날을 만료일로 정하는 것이 가장 쉬울 것 같음 👉 가장 쉬운 것을 테스트로 선택

```java
@DisplayName("만원을 납부하면 한달 뒤가 만료일이다.")
@Test
void pay_10_000_() {
    LocalDate billingDate = LocalDate.of(2024, 3, 1);
    int payAmount = 10_000;

    ExpiryDateCalculator sut = new ExpiryDateCalculator();
    LocalDate result = sut.calculate(billingDate, payAmount);
    
    assertThat(result).isEqualTo(LocalDate.of(2024, 4, 1));
}
```

### 상수로 일단 테스트 통과

```java
public class ExpiryDateCalculator {

    public LocalDate calculate(LocalDate billingDate, int payAmount) {
        return LocalDate.of(2019, 4, 1);
    }

}
```

## 예를 추가하면서 구현을 일반화

```java
@DisplayName("만원을 납부하면 한달 뒤가 만료일이다.")
@Test
void pay_10_000_() {
    // case1
    LocalDate billingDate = LocalDate.of(2024, 3, 1);
    int payAmount = 10_000;

    ExpiryDateCalculator sut = new ExpiryDateCalculator();
    LocalDate result = sut.calculate(billingDate, payAmount);

    assertThat(result).isEqualTo(LocalDate.of(2024, 4, 1));

    // case2
    LocalDate billingDate2 = LocalDate.of(2024, 2, 1);
    LocalDate result2 = sut.calculate(billingDate2, payAmount);

    assertThat(result2).isEqualTo(LocalDate.of(2024, 3, 1));
}
```

- 동일한 조건의 예를 추가하면서 구현을 일반화 해보자.
- 방법 고민
  - 이 때 테스트를 통과 시키기 위해 상수를 한 번 더 쓸까?
  - 바로 구현을 일반화 할까? 👈 이 예는 비교적 단순하므로 바로 일반화 하자.

```java
public class ExpiryDateCalculator {

  public LocalDate calculate(LocalDate billingDate, int payAmount) {
    return billingDate.plusMonths(1L);
  }

}
```

## 코드 정리: 중복 제거

- 리팩토링할 시간이다.
- 프로덕션과 테스트 코드의 리팩토링을 진행해보자.

### 프로덕션: 파라미터를 줄일까?

- `calculate`의 파라미터는 아직 2개.
- 파라미터가 더 많아지면 객체로 분리하는 것을 고려하자.
  - 아직은 파라미터가 더 추가될지 알 수 없고, 발생하지도 않았는데 미리 단정 지어 코드를 수정할 필요는 없다.

### 테스트: 


### 테스트 코드의 중복제거는 고민

## 예외 상황 처리

## 다음 테스트 선택: 다시 예외 상황

## 다음 테스트를 추가하기 전에 리팩토링

## 예외 상황 테스트 진행 계속

## 코드 정리: 상수를 변수로

## 다음 테스트 선택: 쉬운 테스트

## 코드 정리

## 다음 테스트: 10개월 요금을 납부하면 1년 제공

---

# 3. 테스트할 목록 정리하기

---

# 4. 시작이 안 될 때는 단언부터 고민

---

# 5. 구현이 막히면

