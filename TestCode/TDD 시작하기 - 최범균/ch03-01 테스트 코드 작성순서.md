<!-- TOC -->
* [테스트 코드 작성 순서](#테스트-코드-작성-순서)
  * [쉽거나 예외적인 상황부터](#쉽거나-예외적인-상황부터-)
* [초반에 복잡한 테스트부터 시작하면 안 되는 이유](#초반에-복잡한-테스트부터-시작하면-안-되는-이유)
* [구현하기 쉬운 테스트부터 시작하기](#구현하기-쉬운-테스트부터-시작하기)
  * [암호 검사기 예제](#암호-검사기-예제)
* [예외 상황을 먼저 테스트 해야하는 이유](#예외-상황을-먼저-테스트-해야하는-이유)
* [완급 조절](#완급-조절)
* [지속적인 리팩토링](#지속적인-리팩토링)
  * [TDD 과정에서의 지속적인 리팩토링](#tdd-과정에서의-지속적인-리팩토링)
  * [테스트 대상 코드의 리팩토링 시점](#테스트-대상-코드의-리팩토링-시점)
    * [작은 리팩토링은 발견하면 바로 실행](#작은-리팩토링은-발견하면-바로-실행)
    * [메서드 추출과 같은 리팩토링은 신중하게 ⭐️](#메서드-추출과-같은-리팩토링은-신중하게-)
<!-- TOC -->

# 테스트 코드 작성 순서

## 쉽거나 예외적인 상황부터 

- 첫 번째 테스트는 가장 쉽거나 가장 예외적인 상황을 선택.
- TDD로 테스트 작성 순서는,
  - 쉬운 경우에서 어려운 경우로 진행
  - 예외적인 경우에서 정상인 경우로 진행

---

# 초반에 복잡한 테스트부터 시작하면 안 되는 이유

- 초반부터 다양한 조합을 검사하는 복잡한 상황을 테스트 하게 되면, 많은 구현을 해야한다.
- 많은 코드를 만들게 되면, 버그 가능성이 높아지고, 이 버그를 잡기 위해 많은 시간을 쓰게 된다. 
  - 당연히 테스트 통과 시간도 길어지고, 코드 작성 시간이 길어지면 집중력도 떨어져서 흐름이 자주 끊긴다.
  - _(테스트-구현-리팩토링 흐름이 끊긴다는 얘기)_

---

# 구현하기 쉬운 테스트부터 시작하기

- 가장 구현하기 쉬운 경우부터 시작하면 빠르게 테스트 통과가 가능하다.
  - 수 분에서 십여 분 이내에 구현을 완료해서 테스트를 통과시킬 수 있을 만큼 쉬운 것을 선택하자 

## 암호 검사기 예제

암호검사기 예제에서 위 경우에 해당하는 경우는,

- 모든 조건을 충족하는 경우 👈 둘 중 차이가 없어서 이것을 선택
- 모든 조건을 충족하지 않는 경우

그 다음 선택할만한 테스트는

- 모든 규칙을 충족하지 않는 경우,
- 한 규칙만 충족하는 경우
- 두 규칙만 충족하는 경우

이렇게 있는데, `모든 조건을 충족하는 경우`에 대한 테스트를 짠 뒤, <br>
`모든 규칙을 충족하지 않는 경우`에 대한 테스트를 짜려면 사실상 구현을 전부 다해야한다.

따라서, `한 규칙만 충족하는 경우` 또는 `두 규칙만 충족하는 경우`를 선택해서 구현하자. 


---

# 예외 상황을 먼저 테스트 해야하는 이유
# 완급 조절

# 지속적인 리팩토링 ⭐️

## TDD 과정에서의 지속적인 리팩토링

<br>

## 테스트 대상 코드의 리팩토링 시점

### 작은 리팩토링은 발견하면 바로 실행

테스트 대상 코드에서,

- 상수를 변수로 바꾸거나,
- 변수 이름을 변경하는 것 등

의 **작은 리팩토링은 발견하면 바로 실행**. 

<br>

### 메서드 추출과 같은 리팩토링은 신중하게 ⭐️

> 구조 잘못 잡음 -> 다음 테스트 시 코드 복잡성 증대, 구현 어려움 

- 구현 초기에는 구현의 전반적인 흐름을 모른다.
  - 즉, 구현 초기에 메서드 추출 같은 리팩토링을 하게 되면 코드 구조를 잘못 잡을 가능성이 있다.
- 코드 구조를 잘못 잡게되면,
  - 👉 다음 테스트를 통과시키는 과정에서 코드가 복잡해지거나, 구현이 막힐 가능성이 있다.
- 이런 상황이 오면 **구현을 멈추고 메서드 추출 리팩토링을 되돌려야한다!**
  - 리팩토링을 취소해서 코드 원상 복구 후 테스트 진행 -> 그 뒤에 코드 구조가 명확해지면 다시 리팩토링 시도