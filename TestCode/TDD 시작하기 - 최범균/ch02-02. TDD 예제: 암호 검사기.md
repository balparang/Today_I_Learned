<!-- TOC -->
* [들어가기](#들어가기)
  * [암호의 규칙](#암호의-규칙)
  * [아무 검증도 하지 않는 의미 없는 테스트](#아무-검증도-하지-않는-의미-없는-테스트)
* [테스트](#테스트)
  * [첫 번째 테스트: 모든 규칙을 충족하는 경우](#첫-번째-테스트-모든-규칙을-충족하는-경우)
    * [첫 번째 테스트를 선택할 때는 가장 쉽거나 예외적인 상황을 선택한다.](#첫-번째-테스트를-선택할-때는-가장-쉽거나-예외적인-상황을-선택한다)
    * [컴파일 에러 없애기 - 최소한으로 만들기](#컴파일-에러-없애기---최소한으로-만들기)
    * [테스트 통과 시키기](#테스트-통과-시키기)
    * [테스트 하나 더 추가해서 통과하는지 확인](#테스트-하나-더-추가해서-통과하는지-확인)
  * [두 번째 테스트: 길이만 8글자 미만이고 나머지 조건은 충족하는 경우](#두-번째-테스트-길이만-8글자-미만이고-나머지-조건은-충족하는-경우)
<!-- TOC -->

# 들어가기

## 암호의 규칙

```text
### 규칙

- 검사할 규칙은 다음 세 가지이다.
  - 길이가 8글자 이상
  - 0부터 9 사이의 숫자를 포함
  - 대문자 포함


### 암호 강도

- 세 규칙을 모두 충족하면 암호는 강함이다.
- 2개의 규칙을 충족하면 암호는 보통이다.
- 1개 이하의 규칙을 충족하면 암호는 약함이다.
```

## 아무 검증도 하지 않는 의미 없는 테스트

```java
public class PasswordStrengthMeterTest {

	@Test
	void name() {
	}

}
```

- 빈 테스트 메서드이므로 당연히 통과하다.
- **테스트를 실행할 수 있는 환경을 갖추었는지 확인한다**는 관점에서, 그 자체로 나름대로 의미가 있다.

# 테스트

## 첫 번째 테스트: 모든 규칙을 충족하는 경우

### 첫 번째 테스트를 선택할 때는 가장 쉽거나 가장 예외적인 상황을 선택한다.

- 첫 번째 테스트가 중요하다. 
  - 첫 번째 테스트를 잘 선택하지 않으면, 이후 진행과정이 순탄치 않다.

- 첫 번째 테스트를 선택할 때는, **가장 쉽거나 가장 예외적인 상황을 선택해야한다.** ⭐️

- 암호검사기에서 가장 쉽거나 예외적인 상황은, 아래 두 가지가 떠오른다.
  - `모든 규칙을 충족하는 경우`
  - `모든 조건을 충족하지 않는 경우`

- `모든 조건을 충족하지 않는 경우`를 구현하려면, 각 조건을 검사하는 코드를 모두 구현해야한다.
  - 👉 첫 번째 테스트 코드를 통과하는 시간도 길어진다.
  - **_👉 사실상 구현을 다하고 테스트 하는 방식과 다르지 않음._**
    - = TDD를 안 쓰던 시절의 개발 방식

- `모든 규칙을 충족하는 경우`는, 
  - 각 조건을 검사하는 코드를 만들지 않고 '강함'에 해당하는 값만 리턴면 테스트에 통과할 수 있다.
    - 따라서 이 조건으로 먼저 시작한다.

### 컴파일 에러 없애기 - 최소한으로 만들기

```java
@Test
void meetsAllCriteria_then_strong() {
    PasswordStrengthMeter meter = new PasswordStrengthMeter();

    PasswordStrength result = meter.meter("0934AB!@");

    assertThat(result).isEqualTo(PasswordStrength.STRONG);
}
```

- 테스트 패키지에 컴파일 에러를 없애기 위해 클래스, 메서드를 만든다.

```java
public enum PasswordStrength {

	STRONG

}
```

- 약함, 보토을 표현하기 위해 WEAK, NORMAL을 추가할 수도 있지만,
  - **_TDD는 테스트를 통과시킬만큼의 코드를 작성한다._** ⭐️
  - _(내 경험상 yagni를 지키지 못한 경우가 많았는데, TDD가 이를 보완해줄 수 있을 듯!)_

```java
public PasswordStrength meter(String password) {
    return null;
}
```
- STRONG을 바로 리턴할 수도 있지만, 우선은 컴파일 에러를 없애면서 한 스텝씩 밟기.

### 테스트 통과 시키기

- 컴파일 에러를 없애고, 테스트를 돌리면 실패한다. 이제 통과시키러 가보자.

```java
public class PasswordStrengthMeter {

	public PasswordStrength meter(String password) {
		return PasswordStrength.STRONG;
	}

}
```

### 테스트 하나 더 추가해서 통과하는지 확인

```java
@Test
void meetsAllCriteria_then_strong() {
    PasswordStrengthMeter meter = new PasswordStrengthMeter();

    PasswordStrength result = meter.meter("0934AB!@");
    assertThat(result).isEqualTo(PasswordStrength.STRONG);

    PasswordStrength result2 = meter.meter("abc1234A");
    assertThat(result2).isEqualTo(PasswordStrength.STRONG);
}
```

- 첫 번째 테스트를 끝냈으니, 다음 테스트로 가보자.

---

## 두 번째 테스트: 길이만 8글자 미만이고 나머지 조건은 충족하는 경우

