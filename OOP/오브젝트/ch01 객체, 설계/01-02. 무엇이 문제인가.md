<!-- TOC -->
  * [모듈이 가져야하는 세 가지 기능](#모듈이-가져야하는-세-가지-기능)
  * [예상을 빗나가는 코드](#예상을-빗나가는-코드)
    * [현재 Theater 의 enter() 가 하는 일](#현재-theater-의-enter-가-하는-일-)
  * [문제: 관람객과 판매원은 **수동적인 존재**](#문제-관람객과-판매원은-수동적인-존재)
  * [이해 가능하지 않은 코드](#이해-가능하지-않은-코드)
    * [예상에서 벗어나는 코드](#예상에서-벗어나는-코드)
    * [여러가지 세부적인 내용을 기억해야 하는 코드](#여러가지-세부적인-내용을-기억해야-하는-코드)
  * [가장 심각한 문제: 변경에 취약한 코드](#가장-심각한-문제-변경에-취약한-코드)
    * [기존 가정이 변경된다면 흔들린다.](#기존-가정이-변경된다면-흔들린다)
    * [가방을 들고있다는 가정이 바뀐다면...](#가방을-들고있다는-가정이-바뀐다면)
  * [핵심은 불필요한 의존성 제거](#핵심은-불필요한-의존성-제거)
    * [의존성 제거가 능사는 아니다](#의존성-제거가-능사는-아니다)
  * [결합도를 낮추자](#결합도를-낮추자)
<!-- TOC -->

## 모듈이 가져야하는 세 가지 기능

(마틴)

모듈은, 
1. *제대로 실행되어야하고*
2. *변경이 용이해야하며*
3. *이해하기 쉬워야한다. (읽는 사람과의 의사 소통)*

👉 현재 변경 용이성과 읽는 사람과의 의사소통이라는 부분은 만족시키지 못하고 있음.

## 예상을 빗나가는 코드

### 현재 Theater 의 enter() 가 하는 일 

```java
public class Theater {  
  
    private TicketSeller ticketSeller;  
  
    public Theater(TicketSeller ticketSeller) {  
       this.ticketSeller = ticketSeller;  
    }  
  
    public void enter(Audience audience) {  
       if (audience.getBag().hasInvitation()) {  
          Ticket ticket = ticketSeller.getTicketOffice().getTicket();  
          audience.getBag().setTicket(ticket);  
       } else {  
          Ticket ticket = ticketSeller.getTicketOffice().getTicket();  
          audience.getBag().minusAmount(ticket.getFee());  
          ticketSeller.getTicketOffice().plusAmount(ticket.getFee());  
          audience.getBag().setTicket(ticket);  
       }  
    }  
  
}
```

> - 소극장이 직접 관람객 가방 열어서 초대장 있는지 확인
> - 초대장 있으면 판매원은 매표소에 보관된 티켓을 관람객의 가방 안으로 옮김.
> - 가방안에 초대장 없으면 관람객 가방에서 현금을 꺼내서 매표소에 적립하고, 매표소에 보관된 티켓을 관람객의 가방 안으로 옮김.


## 문제: 관람객과 판매원은 **수동적인 존재**

- 관람객과 판매원은 소극장의 통제를 받는 **수동적인 존재**임.
- 관람객 입장에서,
	- 소극장이라는 제 3자가 가방을 마음껏 뒤지고 있음.
- 판매원 입장에서,
	- 소극장이 나(=판매원)의 허락도 없이 티켓을 막 가져가고, 매표소 안에 돈이 쌓이는 것을 두 손 놓고 바라보고 있을 수 밖에 없음.


## 이해 가능하지 않은 코드

### 예상에서 벗어나는 코드

- 이해 가능한 코드란 그 동장이 **우리의 예상에서 크게 벗어나지 않는 코드**다.
- 현실에서, 
	- 관람객은 **직접 자신의 가방**에서 돈을 꺼내서 판매원한테 돈을 건넨다.
	- 판매원은 매표소에 있는 티켓을 **직접** 꺼내서 관람객에게 전달.
- 현재 코드는 그렇지 않은, 즉 **상식과 너무 다르게 동작해서 코드를 읽는 사람과 의사소통 하지 못한다.**

### 여러가지 세부적인 내용을 기억해야 하는 코드

- 이 코드를 이해하기 위해서, 너무 많은 것을 '기억'하고 있어야함.
- Theater의 enter()를 다시 보면, 
	- 관람객이 가방을 가지고 있고, 
	- 가방에는 현금과 티켓이 들어있으며,
	- 판매원이 매표소에서 티켓을 판매하고,
	- 매표소 안에 돈과 티켓이 보관돼 있다는,
	- **위 모든 사실을 동시에 기억하고 있어야함.**

- 👉 ***하나의 클래스나 메서드에서 너무 많은 세부사항을 다루기 때문에 코드를 작성하는 사람뿐만 아니라 코드를 읽고 이해해야하는 사람 모두에게 큰 부담을 준다.***

## 가장 심각한 문제: 변경에 취약한 코드

### 기존 가정이 변경된다면 흔들린다.

- Audience와 TicketSeller를 변경할 경우 Theater도 함께 변경해야한다.
- 이 코드는 관람객이 현금과 초대장을 보관하기 위해 **항상 가방을 들고 다닌다고 가정**하고 있음.
	- 관람객이 가방을 들고 있지 않다면 어떻게 해야할까?
	- 관람객이 현금이 아니라 신용카드를 이용해서 결제한다면?
	- 판매원이 매표소 안이 아닌 밖에서 티켓을 판매해야한다면?
	- 👉 ***항상 하는 가정들이 깨지는 순간 모든 코드가 일시에 흔들린다!!!***

### 가방을 들고있다는 가정이 바뀐다면...

- 관람객이 가방을 들고 있다는 가정이 바뀜
	- Audience에서 Bag을 제거하고,
		- Audience의 Bag에 직접 접근하는 Theater의 enter() 역시 수정해야함.
- 다른 클래스가 Audience 내부에 대해 더 많이 알게 될 수록 Audience를 변경하기 어려워진다.
	- 👉 **의존성**과 관련된 문제


## 핵심은 불필요한 의존성 제거

### 의존성 제거가 능사는 아니다

- 객체 사이의 의존성을 모두 제거하는 것이 정답이 아님
- *객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구성하는 것*
	- 👉 우리의 목표는 애플리케이션 기능을 구성하는 데 필요한 **최소한의 의존성만 유지**하고, **불필요한 의존성을 제거하는 것**


## 결합도를 낮추자

- 객체 사이의 의존성이 과한 경우를 결합도가 높다고 말함.
- 객체들이 합리적인 수준으로 의존할 경우 결합도가 낮다고 말함.
- 결합도가 높을 수록 함께 변경될 확률도 높아지기 때문에 변경하기 어려워진다.
	- 👉 ***설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것***
