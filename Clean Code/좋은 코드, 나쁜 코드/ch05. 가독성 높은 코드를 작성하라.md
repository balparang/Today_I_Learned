> 이번 장에서 다루는 내용
> - 코드가 그 자체로 설명이 되도록 하기 위한 방법
> - 다른 사람들에게 코드의 세부적 내용을 명확하게 함
> - 언어의 기능을 사용할 때 그에 합당한 이유를 가져야함

<!-- TOC -->
* [5.1 서술형 명칭 사용](#51-서술형-명칭-사용)
  * [5.1.1 서술적이지 않은 이름은 코드를 읽기 어렵게 만든다](#511-서술적이지-않은-이름은-코드를-읽기-어렵게-만든다)
  * [5.1.2 주석문으로 서술적인 이름을 대체할 수 없다.](#512-주석문으로-서술적인-이름을-대체할-수-없다)
  * [5.1.3 해결책: 서술적인 이름 짓기](#513-해결책-서술적인-이름-짓기)
* [5.2 주석문의 적절한 사용](#52-주석문의-적절한-사용-)
  * [🤔 NOTE: 상식의 사용](#-note-상식의-사용)
  * [5.2.1 중복된 주석문은 유해할 수 있다.](#521-중복된-주석문은-유해할-수-있다)
    * [불필요한 주석문은 쓸모없는 것을 넘어 더 나쁠 수 있다.](#불필요한-주석문은-쓸모없는-것을-넘어-더-나쁠-수-있다)
  * [5.2.2 주석문으로 가독성 높은 코드를 대체할 수 없다.](#522-주석문으로-가독성-높은-코드를-대체할-수-없다)
    * [주석문이 있는 이해하기 어려운 코드](#주석문이-있는-이해하기-어려운-코드)
    * [가독성이 더 좋아진 코드](#가독성이-더-좋아진-코드)
  * [5.2.4 주석문은 코드의 이유를 설명하는데 유용하다.](#524-주석문은-코드의-이유를-설명하는데-유용하다)
  * [5.2.4 주석문은 유용한 상위 수준의 요약 정보를 제공할 수 있다.](#524-주석문은-유용한-상위-수준의-요약-정보를-제공할-수-있다)
    * [클래스가 수행하는 작업을 요약하는 예시](#클래스가-수행하는-작업을-요약하는-예시)
    * [주석과 문서화의 장단점](#주석과-문서화의-장단점)
* [5.3 코드 줄 수를 고정하지 말라](#53-코드-줄-수를-고정하지-말라)
  * [우리가 신경써야하는 것: 가독성과 오용 방지](#우리가-신경써야하는-것-가독성과-오용-방지)
  * [5.3.1 간결하지만 이해하기 어려운 코드는 피하라](#531-간결하지만-이해하기-어려운-코드는-피하라)
    * [간결하지만 이해가 어려운 코드](#간결하지만-이해가-어려운-코드)
  * [5.3.2 해결책: 더 많은 줄이 필요하더라도 가독성 높은 코드를 작성하라](#532-해결책-더-많은-줄이-필요하더라도-가독성-높은-코드를-작성하라)
    * [잘 명명된 헬퍼 함수와 상수를 정의함으로써 가독성 향상](#잘-명명된-헬퍼-함수와-상수를-정의함으로써-가독성-향상)
    * [단순 코드 줄 수보다 중요한 것은....](#단순-코드-줄-수보다-중요한-것은)
* [5.4 일관된 코딩 스타일을 고수하라](#54-일관된-코딩-스타일을-고수하라)
* [5.5 깊이 중첩된 코드를 피하라](#55-깊이-중첩된-코드를-피하라)
* [5.6 함수 호출도 가독성이 있어야 한다](#56-함수-호출도-가독성이-있어야-한다)
* [5.7 설며오디지 않은 값을 사용하지 말라](#57-설며오디지-않은-값을-사용하지-말라)
* [5.8 익명 함수를 적절하게 사용하라](#58-익명-함수를-적절하게-사용하라)
* [5.9 프로그래밍 언어의 새로운 기능을 적절하게 사용하라](#59-프로그래밍-언어의-새로운-기능을-적절하게-사용하라)
<!-- TOC -->

# 5.1 서술형 명칭 사용

## 5.1.1 서술적이지 않은 이름은 코드를 읽기 어렵게 만든다

```java
class T {
    Set<String> pns = new Set();
    Int s = 0;
    ...
    
    Boolean f(String n) {
        return  s;
    }
}
```

- 이 코드는 설명할 수 없는 코드.

## 5.1.2 주석문으로 서술적인 이름을 대체할 수 없다.


```java
/**
 * 팀을 나타낸다.
 */
class T {
    Set<String> pns = new Set(); // 팀에 속한 선수의 이름
    Int s = 0; // 팀의 점수
    ...
    
    Boolean f(String n) {
        return  s;
    }
}
```

- 코드가 훨씬 더 복잡해 보인다.
  - 작성자와 다른 개발자는 _코드뿐만 아니라 주석 역시 유지보수해야한다._
- 코드를 이해하기 위해 **계속해서 위아래로 스크롤해야한다..**
- `t.f(n)`이 당최 무엇을 호출하는지, 무엇을 리턴하는지 알 수 없다.
- 서술적인 이름의 대안으로 주석을 사용해선 안 된다.

## 5.1.3 해결책: 서술적인 이름 짓기

```java
class Team {
    Set<String> playerNames = new Set();
    Int score = 0;
    
    Boolean containsPlayer(String playerName) {
        return playerNames.contains(playerName);
    }
}
```

- 서술적인 이름을 사용하면 이해하기 쉬운 코드가 된다.
- 위 코드는 주석문을 사용한 것보다 덜 지저분하고, 
  - 개발자가 주석문을 관리할 필요가 없으므로 코드에만 집중 가능.

<br>

---

# 5.2 주석문의 적절한 사용 

- 코드만으로는, 코드가 왜 그 일을 하는지에 대한 이유나 배경을 명확히 하기 어려울 수 있다.
  - 이 때 주석문이 유용하다.

## 🤔 NOTE: 상식의 사용

> - 이번 절에서 주석문의 사용 방법과 시기에 대한 일반적인 지침을 제공하지만 반드시 따라야할 엄격한 규칙은 아님.
> - 어렵고 복잡한 비트 논리나, 코드를 최적화하기 위한 트릭을 사용해야한다면 낮은 층위에서 해당 코드가 무엇을 하는지 알려주는 주석문이 유용할 것이다.

## 5.2.1 중복된 주석문은 유해할 수 있다.

```java
String generateId(String firstName, String lastName) {
    // "{이름}.{성}"의 형태로 ID를 생성한다.
    return firstName + "." + lastName;
}
```

- 주석으로 코드를 설명하지만, **코드 자체로 설명이 되기 때문에 쓸모없는 주석이다.**

### 불필요한 주석문은 쓸모없는 것을 넘어 더 나쁠 수 있다.

- 주석문 역시 유지보수의 대상임.
  - 코드 변경에 따른 주석 수정이 필요.
- 코드가 더러워진다. 코드 100줄 읽는데 100줄의 주석을 읽으랴?
- 추가적인 정보도 제공하지 않는 주석이므로, 개발자의 시간만 낭비할 뿐.

<br>

## 5.2.2 주석문으로 가독성 높은 코드를 대체할 수 없다.

### 주석문이 있는 이해하기 어려운 코드

```java
String generateId(String[] data) {
    // data[0]는 유저의 이름이고, data[1]은 성이다.
    // "{이름}.{성}"의 형태로 ID를 생성한다.
    return data[0] + "." + data[1];
}
```

- 코드 자체가 명확하지 않아 주석문이 유용한 것처럼 보인다.
- 진짜 문제는 코드 가독성이 낮다는 것이다.
  - 명확하지 않은 코드를 주석으로 대체하려하지 말고, 가독성 높은 코드를 작성하는게 중요!

### 가독성이 더 좋아진 코드

```java
String generateId(String[] data) {
    return firstName(data) + "." + lastName(data);
}

String firstName(String[] data) {
    return data[0];
}

String lastName(String[] data) {
    return data[1];
}
```

- 잘 명명된 헬퍼 함수를 사용하면 가독성 높은 코드를 쉽게 작성할 수 있다.
- 코드 자체로 설명이되도록 코드를 작성하자.
  - 유지보수 비용을 줄이고, 주석문의 업데이트 및 잘못된 가능성을 없애준다.

<br>

## 5.2.4 주석문은 코드의 이유를 설명하는데 유용하다.

다음과 같은 경우 유용하다.

> - _제품 또는 비즈니스 의사 결정_
> - _이상하고 명확하지 않은 버그에 대한 해결책_
> - _의존하는 코드의 예상을 벗어나는 동작에 대처_

```java
class User {
    private final Int username;
    private final String firstName;
    private final String lastName;
    private final Version signupVersion;
    ...
    
    String getUserId() {
        if (signupVersion.isOlderThan("2.0")) {
            // (v2.0 이전에 등록한) 레거시 유저는 이름으로 ID가 부여된다.
            // 자세한 내용은 #4218 이슈를 보라.
            return firstName.toLowerCase() + "." + lastName.toLowerCase();
        }
        
        // (v2.0 이후로 등록한) 새 유저는 username으로 ID가 부여된다.
        return username;
    }
}
```
- 위 주석문은 *코드가 존재하는 이유*를 설명한다.
- 코드만으로는 그렇게하는 이유가 분명하지 않으므로, 주석을 사용하여 설명했다.
  - 코드 혼동 방지
  - 수정할 경우 어떤 고려사항이 적용되는지 파악 가능.
- **코드를 약간 지저분하게 만들어도, 위 주석으로 인해 얻는 이점이 더 크다.**
  - 주석문 없이 코드만으로 혼란을 일으킬 수 있는 경우에 해당.

<br>

## 5.2.4 주석문은 유용한 상위 수준의 요약 정보를 제공할 수 있다.

- 책에서, 각 장의 시작 부분에 요약이 있으면, 이것이 내게 유용할지 빠르게 판단 가능.
  - 상위 수준의 주석문도 같은 효과

----

코드 기능에 대한 상위 수준의 문서가 유용한 경우

> - _클래스가 수행하는 작업 및 다른 개발자가 알고 있어야 할 중요한 세부 사항을 개괄적으로 설명하는 문서_
> - _함수에 대한 입력 매개변수 또는 기능을 설명하는 문서_
> - _함수의 반환값이 무엇을 나타내는지 설명하는 문서_


### 클래스가 수행하는 작업을 요약하는 예시

```java
/**
 * 스트리밍 서비스의 유저에 대한 자세한 사항을 갖는다.
 * 
 * 이 클래스는 데이터베이스에 직접 연결하지 않고, 메모리에 저장된 값으로 생성된다.
 * 따라서 이 클래스가 생성된 이후에 데이터베이스에서 이뤄진 변경사항을 반영하지 않을 수 있다.
 */
class User {
    ...
}
```

### 주석과 문서화의 장단점

- 장점
  - 코드만으로는 전달할 수 없는 세부사항 설명 가능
  - 코드가 큰 단위에서 하는 일 요약하는데 유용
- 단점
  - 유지보수가 필요
    - 제때 업데이트 되지 않으면 코드와 맞지 않는다.
    - 코드가 지저분해질 수 있다.

👉 **_장단점 사이에서 균형잡힌 방법으로 주석문을 사용하자!_**

<br>

---

# 5.3 코드 줄 수를 고정하지 말라

- 일반적으로 코드베이스의 코드 줄 수는 적을 수록 좋다.
- 코드 줄이 많으면 읽어야할 코드 양이 늘어나므로, 개발자 인지 부하 증가 가능.
- 단순히 코드 줄 수가 적다고 좋은 것이 아니다. 
  - 간결하더라도 가독성이 먼저다.

<br>

## 우리가 신경써야하는 것: 가독성과 오용 방지

우리가 정말로 신경써야할 것들은 **아래 사항들을 확실하게 하는 것임.**

- 이해하기 쉽다.
- 오해하기 어렵다.
- 실수로 작동이 안 되게 만들기가 어렵다.

<br>

## 5.3.1 간결하지만 이해하기 어려운 코드는 피하라

### 간결하지만 이해가 어려운 코드

```java
Boolean isIdValid(UInt16 id) {
    return countSetBits(id & 0x7FFF) % 2 == ((id & 0x 8000) >> 15);
}
```

- 위 코드는 16비트 ID가 유효한지 확인하는 함수이다.
- 위 코드에서, **유효한 ID의 기준이 무엇인지 즉시 알 수 없다.**
- **이해하기 어렵다.**
  - 다른 개발자는 이 한 줄짜리 코드에서, 모든 세부 사항과 가정들을 도출하기 위해 너무 많은 비용을 써야한다.
- **실수로 작동이 안 되게 만들기가 쉽다.**
  - 이 ID를 인코딩하는 코드가 다른 곳에 있고, 이 코드에서 패리티 비트를 최상위 비트가 아닌 최하위 비트로 쓴다면, 위 예제 코드는 올바르게 동작하지 않는다.
- 간결하지만 거의 이해할 수 없어 다른 개발자가 이해하기 위한 비용이 많이들고, 문서화 되지 않은 가정들로 인해 코드 수정에 상당히 취약하며, 수정된 코드는 제대로 
  동작하지 않기가 쉽다. 

<br>

## 5.3.2 해결책: 더 많은 줄이 필요하더라도 가독성 높은 코드를 작성하라

### 잘 명명된 헬퍼 함수와 상수를 정의함으로써 가독성 향상

```java
Boolean isIdValid(UInt16 id) {
    return extractEncodedParity(id) == calculateParity(getIdValue(id));
}

private const UInt16 PARITY_BIT_INDEX = 15;
private const UInt16 PARITY_BIT_MASK = (1 << PARITY_BIT_INDEX);
private const UInt16 VALUE_BIT_MASK = ~PARITY_BIT_MASK;

private UInt16 getIdValue(UInt16 id) {
    return id & VALUE_BIT_MASK;
}

private UInt16 extractEncodedParity(UInt16 id) {
    return (id & PARITY_BIT_MASK) >> PARITY_BIT_INDEX;
}

// 패리티 비트는 1인 비트의 수가 짝수이면 0이고
// 홀수이면 1이다.
private UInt16 calculateParity(UInt16 value) {
    return countSetBits(value) & 2;
}
```

- 코드의 줄 수가 많다는 것은 기존 코드를 재사용하지 않거나, 무언가를 필요 이상으로 복잡하게 만들고 있다는 경고 신호가 될 수 있는 것은 맞다.
  - 그래서, 코드의 줄 수를 주시하는 것이 일반적으로는 바람직하다.

### 단순 코드 줄 수보다 중요한 것은....

- 이해하기 쉬워야하고,
- 어떤 상황에서도 잘 동작하고,
- 문제가 되는 동작을 할 가능성은 없는지 확인하는 것.

**위 사항들을 효과적으로 하기 위해 더 많은 코드가 필요하다면, 그것은 문제가 되지 않는다.**

<br>

# 5.4 일관된 코딩 스타일을 고수하라

# 5.5 깊이 중첩된 코드를 피하라

# 5.6 함수 호출도 가독성이 있어야 한다

# 5.7 설며오디지 않은 값을 사용하지 말라

# 5.8 익명 함수를 적절하게 사용하라

# 5.9 프로그래밍 언어의 새로운 기능을 적절하게 사용하라

