<!-- TOC -->
* [인덱스란?](#인덱스란)
  * [[실습] 인덱스 직접 설정해보기 / 성능 측정해보기](#실습-인덱스-직접-설정해보기--성능-측정해보기)
    * [데이터 준비](#데이터-준비)
    * [성능 측정](#성능-측정)
    * [(팁💡) 성능 측정 시 주의할 점: 정확한 시간](#팁-성능-측정-시-주의할-점-정확한-시간)
    * [인덱스 생성 후 성능 측정](#인덱스-생성-후-성능-측정)
    * [인덱스 생성 시 주의점](#인덱스-생성-시-주의점)
* [기본으로 설정되는 인덱스(PK)](#기본으로-설정되는-인덱스pk)
  * [PK 변경 시 자동으로 정렬되서 저장한다.](#pk-변경-시-자동으로-정렬되서-저장한다)
    * [PK 변경 후 조회](#pk-변경-후-조회)
  * [클러스터링 인덱스](#클러스터링-인덱스)
* [제약 조건을 추가하면 자도으로 생성되는 인덱스(UNIQUE)](#제약-조건을-추가하면-자도으로-생성되는-인덱스unique)
* [[실습] 인덱스를 무식하게 많이 걸면 어떻게 될까?](#실습-인덱스를-무식하게-많이-걸면-어떻게-될까)
* [멀티 컬럼 인덱스(Multiple-Column Index)란?](#멀티-컬럼-인덱스multiple-column-index란)
  * [[실습] 멀티 컬럼 인덱스 직접 설정해보기 / 작동 방식 이해하기](#실습-멀티-컬럼-인덱스-직접-설정해보기--작동-방식-이해하기)
  * [멀티 컬럼 인덱스 생성 시 주의점](#멀티-컬럼-인덱스-생성-시-주의점)
* [커버링 인덱스(Covering Index)란?](#커버링-인덱스covering-index란)
<!-- TOC -->

# 인덱스란?

- 인덱스
  - **_데이터를 빨리 찾기 위해 특정 컬럼을 기준으로 미리 정렬해놓은 표_**

<img alt="img.png" height="400" src="images/img.png"/>

- 나이가 23살인 사용자를 직접 찾으려고 하면, 나이순으로 정렬되어있지 않기 때문에 모든 행을 비교해가면서 23살인 사용자를 찾아야한다. 
  - 즉, 1만개의 **데이터를 모두 확인**해야하므로 시간이 오래걸림.

<img alt="img_1.png" height="500" src="images/img_1.png"/>

- 하지만 위 표와 같이 미리 나이순으로 정렬된 표가 있다면 어떨까?

![img_2.png](images/img_2.png)

- 나이가 23살인 사용자를 찾기 위해서는 표에서 나이가 **23살로 시작하는 지점과 24살로 시작되는 지점**만 찾은 뒤, **그 사이에 있는 모든 값**을 가져오면 됨. 
  - 여기서 나이 순으로 정렬된 표가 인덱스. (정확하게는 나이 컬럼을 기준으로 생성한 인덱스)
- 인덱스를 생성한다고 해서 실제로 볼 수는 없고, 시스템 내부적으로 생성될 뿐임.

> ⭐️ 인덱스는 데이터를 빨리 찾기 위해 **특정 컬럼을 기준으로 미리 정렬해놓은 표**이다.



## [실습] 인덱스 직접 설정해보기 / 성능 측정해보기

### 데이터 준비

```sql
DROP TABLE IF EXISTS users; # 기존 테이블 삭제

CREATE TABLE users (
   id INT AUTO_INCREMENT PRIMARY KEY,
   name VARCHAR(100),
   age INT
);
```

```sql
-- MySQL 세션의 최대 재귀 깊이를 1_000_000 으로 설정
-- (아래에서 생성할 더미 데이터의 개수와 맞춰서 작성하면 된다.)
SET SESSION cte_max_recursion_depth = 1000000;

-- 더미 데이터 삽입 쿼리
INSERT INTO users (name, age)
WITH RECURSIVE cte (n) AS
(
  SELECT 1 -- 기본케이스
  UNION ALL
  SELECT n + 1 FROM cte WHERE n < 1000000 -- 재귀 케이스
)
SELECT
    CONCAT('User', LPAD(n, 7, '0')),   -- 'User' 다음에 7자리 숫자로 구성된 이름 생성
    FLOOR(1 + RAND() * 1000) AS age    -- 1부터 1000 사이의 랜덤 값으로 나이 생성
FROM cte;

-- 잘 생성됐는 지 확인
SELECT COUNT(*) FROM users;
```

- CTE(Common Table Expression): 일시적으로 명명된 결과 집합. 
- 재귀적 CTE: 
  - 자기 자신을 참조하는 CTE.
  - 기본 케이스와 재귀 케이스로 나뉨
    - 기본 케이스: `SELECT 1`
      - 시작값 1을 생성.
    - 재귀 케이스: `SELECT n + 1 FROM cte WHERE n < 10000`
      - 이전 값에 1을 더한 새 값을 생성.
      - 이 과정을 1_000_000에 도달할 때까지 반복

```text
INSERT INTO users (name, age)
SELECT
    CONCAT('User', LPAD(n, 7, '0')),
    FLOOR(1 + RAND() * 1000) AS age
FROM cte;
```

- 데이터 삽입하는 부분:
  - CTE에서 생성된 각 숫자에 대해 사용자 데이터를 생성한다.

```sql
select * from users
where age = 300;
```

### 성능 측정

- 성능을 측정해보면 대략 150ms 이 걸린다.

### (팁💡) 성능 측정 시 주의할 점: 정확한 시간

- 어떤 SQL이 느린 것 같다, 빠른 것 같다라는 것은 X
- 성능 개선할 때는 **수치를 정확히 측정**해서(ms), 이전과 이후를 정확히 비교하는 것이 중요. (몇 배 향상)
  - 몇ms 가 걸렸는데, 몇 ms로 개선했는지를 정확히 봐야함.
  
### 인덱스 생성 후 성능 측정

```sql
create index idx_age on users (age);
show index from users;
```

- 설정하고 성능 측정해보니 30ms 정도로 확연히 속도가 향상됨.

### 인덱스 생성 시 주의점

- 전체 row에 락이 걸리므로 그동안은 DB 접근을 할 수 없다?


> >  by claude 3.5
> 
> 이 말은 일부 맞지만, MySQL 버전과 사용하는 스토리지 엔진에 따라 다릅니다. 좀 더 자세히 설명해 드리겠습니다:
> 
> - MyISAM 엔진: 
>   -  전통적으로 MyISAM 엔진에서는 인덱스 생성 시 전체 테이블에 락이 걸립니다.
>   이는 운영 중 인덱스 생성을 어렵게 만듭니다.
> 
> 
> - InnoDB 엔진:
>  - MySQL 5.5 이전 버전: InnoDB도 인덱스 생성 시 전체 테이블 락을 사용했습니다.
>  - MySQL 5.6 이후 버전: "온라인 DDL" 기능이 도입되었습니다.
>    -  이 기능으로 인해 대부분의 인덱스 생성 작업이 다른 작업을 차단하지 않고 수행될 수 있습니다. 
>    - 단, 작업 초기와 마지막에 짧은 메타데이터 락이 필요합니다.
> - MySQL 8.0 이후: 
>   - 인스턴트 DDL, 원자적 DDL 등 더욱 개선된 기능들이 도입되었습니다.
>   - 이로 인해 많은 DDL 작업들이 더욱 빠르고 효율적으로 수행될 수 있게 되었습니다.
> 
> 따라서, 최신 버전의 MySQL과 InnoDB 엔진을 사용한다면, 대부분의 경우 운영 중에도 인덱스를 생성할 수 있습니다. 하지만 여전히 주의가 필요합니다:
> 
> - 대용량 테이블의 경우, 인덱스 생성이 오래 걸릴 수 있어 서버 부하를 증가시킬 수 있습니다.
> - 특정 상황에서는 여전히 락이 발생할 수 있으므로, 중요한 운영 시간에는 가급적 피하는 것이 좋습니다.
> - 실제 적용 전 테스트 환경에서 충분한 검증을 거치는 것이 안전합니다.


# 기본으로 설정되는 인덱스(PK)

## PK 변경 시 자동으로 정렬되서 저장한다.

```sql
DROP TABLE IF EXISTS users; # 기존 테이블 삭제

CREATE TABLE users
(
    id   INT PRIMARY KEY,
    name VARCHAR(100)
);

INSERT INTO users (id, name)
VALUES (1, 'a'),
       (3, 'b'),
       (5, 'c'),
       (7, 'd');
```

```sql
SELECT * FROM users;
```

![img.png](images/img01/img.png)

- 위처럼 데이터를 준비하고 조회 시 결과 PK를 기준으로 정렬된 것을 확인 가능.

### PK 변경 후 조회

```sql
UPDATE users
SET id = 2
WHERE id = 7;

SELECT * FROM users;
```

![img_1.png](images/img01/img_1.png)

- 조회 시 데이터 추가 순이 아닌 PK 기준으로 정렬된 것을 확인 가능.


## 클러스터링 인덱스

![img_2.png](images/img01/img_2.png)

- PK를 기준으로 데이터가 정렬된 것처럼, **원본 데이터 자체가 정렬되는 인덱스**를 `클러스터링 인덱스`라고한다.
- `PK = 클러스터링 인덱스`라고 이해해도 된다. 
  - 클러스터링 인덱스는 PK밖에 없기 때문. 

```sql
show index from users;
```

![img_3.png](images/img01/img_3.png)

- PK에 대한 인덱스가 있는지 조회하면 `PRIMARY`라는 이름으로 인덱스가 존재한다. 

> ⭐️
> - **PK에는 인덱스가 기본으로 적용**됨. 
> - PK에는 인덱스가 적용되어 있으므로, **PK를 기준으로 데이터가 정렬**된다.




# 제약 조건을 추가하면 자도으로 생성되는 인덱스(UNIQUE)

# [실습] 인덱스를 무식하게 많이 걸면 어떻게 될까?

# 멀티 컬럼 인덱스(Multiple-Column Index)란?

## [실습] 멀티 컬럼 인덱스 직접 설정해보기 / 작동 방식 이해하기

## 멀티 컬럼 인덱스 생성 시 주의점

# 커버링 인덱스(Covering Index)란?
