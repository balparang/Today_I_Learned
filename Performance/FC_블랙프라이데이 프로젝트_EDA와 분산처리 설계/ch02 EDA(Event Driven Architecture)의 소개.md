<!-- TOC -->
* [EDA를 구성하기 위한 요소들](#eda를-구성하기-위한-요소들)
  * [구성 요소](#구성-요소)
    * [이벤트 생산자](#이벤트-생산자)
    * [이벤트 소비자](#이벤트-소비자)
    * [이벤트 브로커](#이벤트-브로커)
<!-- TOC -->

# EDA를 구성하기 위한 요소들

## 구성 요소

### 이벤트 생산자

- 이벤트를 발행하는 주체.
- 특정 이벤트의 발생 또는 상태 변경을 '발행'.
- 소비자를 특정하지 않는다.

### 이벤트 소비자

- 이벤트를 소비하는 주체.
- 특정 이벤트에 다수의 소비자가 존재 가능.
- 한 이벤트에 대해 여러 소비자가 작업을 시작하는 병렬 처리 가능.
  - 하나의 이벤트에 대해 처리되는 작업이 여러 개가 된다.
  - 만약에 API 구조라면, 작업을 시작하는 서비스(=서비스 A)에서 다른 여러 서비스를 다 호출해줘야하기 때문에, `서비스 A`의 부하가 심해진다.

### 이벤트 브로커

- 이벤트 생산자, 소비자를 연결하는 핵심 요소
- 일종의 큐(Queue) 역할
- 일정 기간 이벤트를 저장할 수 있는 기능 필요.
- 단일 장애 포인트가 될 수 있음.
  - 단일 장애 포인트에서 벗어나기 위한 장치들이 있다.
    - 클러스터 (분산된 시스템)를 통해서 이벤트 브로커를 구축하게 되고, 나름의 장애 복구 포인트.
- 다수의 연결(생산자, 소비자)을 처리할 수 있는 확장성 필요.
  - 높은 이벤트 처리량을 위해서는 확장성도 중요.
- 이벤트 브로커의 신뢰성을 높이기 위해서 오류 처리(예: Dead Letter Queue) 기능 필요.
  - 제대로 처리되지 않은 이벤트를 이벤트 브로커가 보관해주는 것(=Dead Letter Queue)
    - 예: 10번 이라는 이벤트가 발행되어서, 소비자가 이것을 받아갔는데, 처리를 하다가 에러가 나서 서비스가 죽었음. 
      - 그럼 이제 이 10번에 대한 처리가 제대로 된 것인지 알 수가 없다.
      - 이런 것을 방지하기 위한 방법 중 하나는 카프카가 소비자에게 이 이벤트가 제대로 처리된 것이 확인을 받는 것이다. 
        - 소비자는 이 이벤트를 받아가고 제대로 처리되었음을 알리기 위해서 커밋을 한다. 
          - 그럼 카프카는 해당 컨슈머에 대해서는 해당 컨슈머에 대해서는 이벤트가 처리되었다고 
            처리하고, 그 다음 이벤트인 11번 이벤트에 대해 처리하게 된다.
          - 이런 경우에도 문제가 생겼다면 이러한 메시지들을 보관하는 DLQ라는 저장소에 따로 만들어 놓기도 한다.

