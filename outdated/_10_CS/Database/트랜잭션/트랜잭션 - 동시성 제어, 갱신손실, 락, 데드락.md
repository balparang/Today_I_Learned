# 동시성 제어(concurrency control)

여러 개의 트랜잭션이 한 개의 데이터를 동시에 갱신(update)할 때 어느 한 트랜잭션의 갱신이 무효화 될 수 있는데 이를 갱신손실이라고 한다. 동시성 제어를 통해 갱신손실을 미리 막을 수 있다. 즉, 트랜잭션이 동시에 수행될 때 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능을 동시성 제어라고한다. 

갱신손실 문제를 해결하기 위한 방법중에 하나로 데이터 수정 중에 있는 트랜잭션은 해당 데이터를 락으로 잠금장치하여 다른 트랜잭션이 접근하지 못하게 하는 방법이 있다. 락 걸린 데이터는 언락이 될 때까지 다른 트랜잭션들을 접근하지 못하고 기다려야한다. 

## 동시성 제어와 갱신손실 문제

### 동시성 제어란?

- 동시에 수행되는 트랜잭션은 다른 트랜잭션이 같은 데이터를 공유하고 있다는 사실을 모르기 때문에 데이터 일관성이 훼손될 수 있다. **_트랜잭션이 동시에 수행될 때 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능을 `동시성 제어(concurrency control)`라고한다._**


### 갱신손실 문제란?

- **_여러 개의 트랜잭션이 한 개의 데이터를 동시에 갱신(update)할 때 어느 한 트랜잭션의 갱신이 무효화_** 될 수 있는데 이를 `갱신손실 문제`라고 한다.
- 갱신손실 문제는 데이터베이스에서 절대 발생하면 안 되는 문제이다.
- 갱신작업이 무효화 되는 경우 예시
![](https://velog.velcdn.com/images/balparang/post/15a8e59e-9283-45ae-840c-e32c292a2be8/image.png)
  - `트랜잭션2`는 100을 더하는 연산이고, `트랜잭션3`은 100을 빼는 연산이다. 따라서 두 트랜잭션 이후에 데이터는 그대로 일 것을 예상.
  - `트랜잭션3`에서 A값(=1000)을 읽고 `A = A - 100`연산을 수행. 이 때 A는 900
  - `트랜잭션2`에서 A값(=1000)을 읽고 `A = A + 100`연산을 수행. 이 때 A는 1100
  - `트랜잭션3`에서 A값(=900) write. A값이 900으로 변경된다.
  - `트랜잭션2`에서 A값(=1100) write. A값이 1100으로 변경된다.
  - `갱신손실 문제`가 발생하여, 데이터값이 그대로 유지될 것이라는 예상과는 다르게 결과가 나온다.

## 락

### 락의 개념

- 락이란, 트랜잭션이 데이터를 읽거나 수정할 때 데이터에 표시하는 잠금장치
- 락을 건 트랜잭션만 해당 데이터에 접근 가능
- 락을 사용하여 데이터에 대한 갱신을 순차적으로 진행할 수 있기 때문에, `갱신손실` 문제를 해결할 수 있다.

### Lock을 통한 동시성 제어

![](https://velog.velcdn.com/images/balparang/post/3a357798-275c-4359-a68a-eff48ecfce48/image.png)

- `트랜잭션3` 이 시작할 때 락을 건다.
  - `트랜잭션3` A(=1000)를 읽고, `A = A - 100` 연산을 수행한다. (A = 900)
  - `트랜잭션2`가 A에 접근하려고 하나 락이 걸려있어 wait를 한다.(언락이 될 때까지). 
  - `트랜잭션3`이 쓰기작업을 마치고 언락. (A = 900)
- `트랜잭션2`가 실행되고 락을 건다.
  - A(=900)를 읽고, `A = A + 100` 연산을 수행. (A = 1000)
  - `트랜잭션2`가 쓰기작업을 마치고 언락. (A = 1000)

### 락의 유형

### 2단계 락킹

## 데드락 

### 데드락이란?

- 두 트랜잭션이 각각 Lock을 설정하고, Unlock을 하지 않은 상태에서 서로의 Lock이 걸린 데이터에 접근하려고 할대, 서로 대기를 계속하여 영원히 처리되지 않는 상황이 발생하는데 이를 `데드락`이라한다.

- 데드락 예시

  ![](https://velog.velcdn.com/images/balparang/post/860f8b27-4298-42c7-9a8f-10c89cd2ba9a/image.png)

  - 두 개 이상의 트랜잭션이 실행되는 **병행적인 상황**
  - `트랜잭션2`는 테이블 A의 데이터가 필요하여 Lock A를 걸었다.
  - `트랜잭션1`은 테이블 B의 데이터가 필요하여 Lock B를 걸었다.
  - `트랜잭션2`가 테이블 B의 데이터가 필요하여 접근하여 락을 걸려 했으나, `트랜잭션1`이 이미 걸어둔 Lock 때문에 접근하지 못하고 Unlock되기를 기다린다.
  - `트랜잭션1`은 테이블 A의 데이터가 필요하여 접근하려 락을 했으나, `트랜잭션2`가 이미 걸어둔 Lock 때문에 접근하지 못하고 Unlock되기를 기다린다. 
  - 두 트랜잭션이 상대의 락이 언락되기만을 기다리면서 무제한 대기하는 상태가 발생한다 👉 `DeadLock` 

### 데드락 해결법

1. 예방 기법
   - 각 트랜잭션이 실행되기 전에 필요한 데이터를 모두 Locking 한다. 
   - 단, Locking 해줘야 하는 데이터가 하는 데이터가 많다면 사실상 모든 데이터를 전부 Locking하는 것과 동일하여 트랜잭션의 병행성을 보장하지 못 할 수 있다.
2. 회피 기법
   - 자원을 할당할 때 `time stamp`를 사용하여 데드락이 일어나지 않도록 회피하는 방법
3. 탐지/회복 기법
   - 트랜잭션이 실행되기 전에는 아무런 검사를 하지 않고, 데드락이 발생하면 이를 감지하고 회복시키는 방법

---

## 🗣️ 면접 대비

### Q. 읽기에는 락을 걸지 않아도 될까요?

- 상황마다 다르다
- 읽기 작업만 할 때는 트랜잭션이 필요 없다.  
- 쓰기 작업을 할 때는 트랜잭션이 필요하다. 