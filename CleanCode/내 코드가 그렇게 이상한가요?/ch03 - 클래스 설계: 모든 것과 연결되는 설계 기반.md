<!-- TOC -->
* [3.1 클래스 단위로 잘 동작하도록 설계하기](#31-클래스-단위로-잘-동작하도록-설계하기)
  * [3.1.1 클래스의 구성 요소](#311-클래스의-구성-요소)
    * [잘 만들어진 클래스](#잘-만들어진-클래스)
    * [왜 변수랑 메서드를 같이 묶어야 하나?](#왜-변수랑-메서드를-같이-묶어야-하나)
  * [3.1.2 모든 클래스가 갖추어야 하는 자기 방어 임무](#312-모든-클래스가-갖추어야-하는-자기-방어-임무)
* [3.2 성숙한 클래스로 성장시키는 설계 기법](#32-성숙한-클래스로-성장시키는-설계-기법)
* [3.3 악마 퇴치 효과 검토하기](#33-악마-퇴치-효과-검토하기)
* [3.4 프로그램 구조의 문제 해결에 도움을 주는 디자인 패턴](#34-프로그램-구조의-문제-해결에-도움을-주는-디자인-패턴)
<!-- TOC -->

# 3.1 클래스 단위로 잘 동작하도록 설계하기

- **클래스 단위로도 잘 동작하게 설계해야 한다.** 가 핵심.
- 클래스 그 자체로도 잘 동작할 수 있게 설계해야한다.

## 3.1.1 클래스의 구성 요소

- 클래스의 구성 요소
  - 인스턴스 변수
  - 메서드

### 잘 만들어진 클래스

- 잘 만들어진 클래스의 구성 요소
  - 인스턴스 변수
  - 인스턴스 변수에 잘못된 값이 할당됮 않게 막고, 정상적으로 조작하는 메서드

### 왜 변수랑 메서드를 같이 묶어야 하나?

- 데이터와 로직이 따로 있으면 연관성을 알아채기 어렵다.
- 코드가 중복될 수 있다.
  - 중복 코드는 수정하다가 다른 코드의 수정을 놓칠 수도 있다.
- 한 곳에 있지 않으므로, 가독성을 낮춘다.


## 3.1.2 모든 클래스가 갖추어야 하는 자기 방어 임무

- 클래스 스스로 자기 방어 임무를 수행해야 소프트웨어 품질을 높일 수 있다.

# 3.2 성숙한 클래스로 성장시키는 설계 기법

## 3.2.1 생성자로 확실하게 정상적인 값 설정하기

```java
public class Money {

    int amount;
    Currency currency;

    public Money(final int amount, final Currency currency) {
        if (amount < 0) {
            throw new IllegalArgumentException("금액은 0 이상의 값을 지정해주세요.");
        }

        if (Objects.isNull(currency)) {
            throw new IllegalArgumentException("통화 단위를 지정해주세요.");
        }

        this.amount = amount;
        this.currency = currency;
    }

}
```

- 잘못된 값이 유입되지 못하게 유효성 검사(`validation`)을 생성자 내부에 정의한다.

### 가드

- 위 코드의 생성자처럼 처리 범위를 벗어나는 조건을 메서드 가장 앞부분에서 확인하는 코드를 '가드'라고 한다.
- 생성자에 가드를 배치 시, 항상 안전하고 정상적인 인스턴스만 존재하게 된다.

## 3.2.2 계산 로직도 데이터를 가진 쪽에 구현하기

- 데이터와 데이터를 조작하는 로직이 분리되어 있는 구조는 '응집도가 낮은 구조'이다.
- 데이터와 데이터 조작 로직을 모아서, 클래스를 성숙하게 만들자.

```java
public class Money {

    int amount;
    Currency currency;

    public Money(final int amount, final Currency currency) {
        if (amount < 0) {
            throw new IllegalArgumentException("금액은 0 이상의 값을 지정해주세요.");
        }

        if (Objects.isNull(currency)) {
            throw new IllegalArgumentException("통화 단위를 지정해주세요.");
        }

        this.amount = amount;
        this.currency = currency;
    }

    // 추가
    public void addAmount(final int other) {
        this.amount += other;
    }

    public int getAmount() {
        return this.amount;
    }

}
```

## 3.2.3 불변 변수로 만들어서 예쌍하지 못한 동작 막기

## 3.2.4 변경하고 싶다면 새로운 인스턴스 만들기

## 3.2.5 메서드 메서드 매개변수와 지역 변수도 불변으로 만들기 

## 3.2.6 엉뚱한 값을 전달하지 않도록 하기

## 3.27 의미 없는 메서드 추가하지 않기

# 3.3 악마 퇴치 효과 검토하기

# 3.4 프로그램 구조의 문제 해결에 도움을 주는 디자인 패턴