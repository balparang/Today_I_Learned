> # 트랜잭션 격리 수준이란 무엇이고 왜 필요할까


# 들어가며

트랜잭션 격리 수준이란, 한 트랜잭션이 사용 중인 데이터에 대해 다른 트랜잭션의 접근 허용 정도를 결정하는 것을 말한다. 트랜잭션 격리 수준은 아래와 같이 4단계로 나뉘며, 격리 수준을 조절함으로써, 복수의 트랜잭션이 같은 데이터를 읽고 쓰면서 생기는 `Dirty Read`, `Non-Repeatable Read`, `Phantom Read` 와 같은 문제들을 해결할 수 있다.  

- Read Uncommitted(Level 0)
- Read Committed(Level 1)
- Repeatable Read(Level 2)
- Serializable(Level 3)

격리 수준이 높아질수록 동시성(Concurrency)은 낮아지지만, 이에 반비례하여 데이터 일관성(Consistency)  
본 포스팅에서는 각 격리 수준을 살펴보며, 각 단계에서 어떤 문제들을 해결할 수 있는지 알아본다.

<br>

# 트랜잭션 격리 수준

## Read Uncommitted

`Read Uncommitted`는 커밋되지 않은 데이터를 다른 트랜잭션이 조회할 수 있도록 허용하는 격리 수준이다. 따라서 커밋되지 않은 데이터를 조회함으로써 생기는 `Dirty Read` 문제가 발생할 수 있다. 

## Read Committed

### Dirty Read: 커밋되지 않은 데이터를 읽기

<img width="867" alt="image" src="https://github.com/haero77/Today-I-Learned/assets/65555299/e2aa4d76-0a15-46c3-a90d-8a484eca0b44">

Dirty Read란, 트랜잭션이 커밋되지 않은 상태에서 데이터를 읽음으로써 생기는 문제이다. 위 예시로 살펴보자.

- 트랜잭션 B가 age=20으로 갱신한다.
- 트랜잭션 A는 변경된 age=20을 조회한다.
- 트랜잭션 B에서 롤백이 발생하고, 실제 데이터는 age=30으로 롤백된다.
- 트랜잭션 A는 실제 데이터와 상관없는 값인 age=20을 가지고 작업을 진행한다. 👉 문제 발생

트랜잭션 B가 실행 중일 때, 커밋 되지 않은 age값을 읽었기 때문에 발생했다. 

## Repeatable Read

### Non-Repeatable Read

## Serializable

### Phantom Read


- 여러 클라이언트가 같은 데이터에 접근할 때(Race Condition) 문제 발생
- 가장 쉬운 방법은 트랜잭션을 순차적으로 수행하면 되지만, 성능(처리량)이 저하 될 수 있다. 
- 동시 접근 문제가 아예일어나지 않는다.
- 트랜잭션을 격리하는데, 어느 정도로 

## 트랜잭션 격리 수준이란


### Read Uncommitted




### Read Committed



### Repeatable Read

- MySQL의 innoDB엔진의 기본 격리 수준이기도 하다.

### Serializable

# 마치며

### 📝 Reference

- https://www.ibm.com/docs/en/i/7.3?topic=transactions-transaction-isolation-levels
- [프로그래밍 초식 : DB 트랜잭션 조금 이해하기 02 격리](https://youtu.be/poyjLx-LOEU)
- [DB 트랜잭션 격리 수준 제대로 이해하기 - 1편](https://www.youtube.com/watch?v=sDSU8KrOcxc)
- 데이터베이스 개론과 실습 - 박우창 저
- https://hudi.blog/transaction-isolation-level/