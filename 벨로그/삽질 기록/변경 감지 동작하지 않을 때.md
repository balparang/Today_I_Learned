# 변경 감지가 동작하지 않을 때 

## 상황 

```java
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Entity
public class Member {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "member_id")
	private Long id;

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "team_id")
	private Team team;

        ...
	
	public void changeTeam(Team team) {
		this.team = team;
	}

}
```

- 더티 체킹을 이용하여 Team 을 이용하려고 한다. 

```java
@RequiredArgsConstructor
@Transactional
@Service
public class MemberCommandService {

    private final TeamRepository teamRepository;
    private final MemberRepository memberRepository;
        
    public MemberTeamChangeResponse changeTeam(MemberTeamChangeRequest request) {
       Member findMember = findMemberById(request.getMemberId());
       Team findTeam = teamQueryService.findTeamById(request.getMemberId()); 
    
       findMember.changeTeam(findTeam); // 더티 체킹 발생 안 함
    
       return new MemberTeamChangeResponse(findMember.getId(), findTeam.getId());
    }
    
    private Member findMemberById(Long id) {
       return memberRepository.findById(id)
           .orElseThrow(() -> new IllegalArgumentException("There is no member matching the given id."));
    }

}

```

- 위 서비스 객체에서 changeTeam()은 변경감지가 동작하지 않는데, 
  - 그 이유는 `teamQueryService.findTeamById(request.getMemberId());` 가 **readOnly=true 옵션으로 가져왔기 때문.**

```java
@RequiredArgsConstructor
@Transactional(readOnly = true)
@Service
public class TeamQueryService {

    private final TeamRepository teamRepository;
    
    public Team findTeamById(Long id) {
        return teamRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("There is no team matching the given id."));
    }
	
}
```

- `readOnly = true`를 사용하지 않고 서비스 객체에서 바로 teamRepository 에 접근하여 team을 찾으면 정상적으로 변경 감지 작동한다.

```java
@RequiredArgsConstructor
@Transactional
@Service
public class MemberCommandService {

    private final MemberRepository memberRepository;
    private final TeamRepository teamRepository;
    private final TeamQueryService teamQueryService;
    
    public MemberTeamChangeResponse changeTeam(MemberTeamChangeRequest request) {
		
        ...
      
        // readOnly = true 옵션 없이 사용.  
        Team findTeam = teamRepository.findById(request.getTeamId()).get();
		
        ...
        
    }

}

```

## 남은 의문

<img width="1312" alt="image" src="https://github.com/haero77/Today-I-Learned/assets/65555299/12b05ea2-2e14-486e-955e-cfc39ed4a376">

- UPDATE 쿼리가 트랜잭션 안에서 처리 되어야 할 것 같은데, 정작 UPDATE 쿼리 전에 트랜잭션이 커밋 되고, UPDATE 쿼리 이후에 커밋되었다는 로그가 없다. 
  - JPA에서 모든 변경, 생성은 트랜잭션 안에서 이루어져야한다고 알고 있는데, 왜 이렇게 로그가 나오는지 헷갈린다. 
