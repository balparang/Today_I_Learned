# 객체 지향 프로그래밍과 객체 지향의 4가지 특징(캡슐화, 상속, 추상화, 다형성)

![](https://velog.velcdn.com/images/balparang/post/90afe9f9-21c1-4ad8-8a2b-bda08be4e1f1/image.png)



# 들어가며
[객체지향의 사실과 오해](http://www.yes24.com/Product/Goods/18249021), [최범균님의 객체 지향 프로그래밍 입문](https://www.inflearn.com/course/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%85%EB%AC%B8) 등 책과 강의를 통해 OOP와 관련된 개념을 학습했고,   `백엔드 데브코스`에서 미션을 진행하며 _"메시지를 보내보세요"_ 등의 객체 지향과 관련된 리뷰를 많이 받았다. 그 과정속에서 `객체 지향적으로 코드를 짜려면 어떻게 해야하는가?`라는 물음을 끊임없이 던지며 프로젝트를 해왔고, 내 나름대로의 `객체 지향이란 무엇인가?`에 대한 기준을 가지게 되었다. 본 포스팅에서는 그간 배운 내용을 정리하고, 필자가 생각하는 OOP에 대해서도 견해를 남긴다. 본 포스팅은 `객체 지향 프로그래밍`, `객체`, `객체 지향의 4가지 특징(캡슐화, 상속, 추상화, 다형성)`에 대해 다룬다.


# 객체 지향 프로그래밍

## 객체 지향 프로그래밍이란 무엇인가

객체 지향 프로그래밍이란 `데이터`와 `프로시`를 객체 단위로 묶고, 특정 객체가 갖고 있는 데이터는 오로지 해당 객체의 `프로시저`를 통해서 접근 가능하게 프로그래밍 하는 방식을 말한다. 또한 객체와 객체는 `프로시저`를 호출하는 방식으로 연결된다. 여기서 말하는 `프로시저`란 어떤 작업을 하기 위해 수행하는 명령문을 의미한다. 

예시를 통해 `데이터`와 `프로시저`가 무엇인지 이해하고, 어떻게 하면 이 둘을 묶어서 프로그래밍할 수 있을지 살펴보자.

### 여러 프로시저에서 데이터를 공유하는 경우

**🧑‍💻상황**

- 나는 회원 인증과 관련된 API를 개발하는 개발자이고, 인증 API와 암호 변경 API를 개발하려고 한다. 
- 인증과 암호 변경을 하기 위해서는 회원이 삭제된 상태가 아니어야한다.
- `회원` 클래스는 `회원 상태`와 `차단된 횟수`를 필드로 가진다.

먼저 아래는 `회원`과 `회원 상태` 클래스이다. 

```java
// 회원 상태
enum MemberState {
	ACTIVE,
	DELETED
}

// 회원 클래스
class Member {
	private MemberState state; // 회원 상태
	private int blockCount; // 차단된 횟수

	public Member(MemberState state) {
		this.state = state;
	}

	// Getter

	// ...
}
```
이제 `인증 API`와 `암호 변경 API`를 구현해보자. 인증과 암호변경을 할 때 회원이 삭제된 상태가 아니어야 하므로, `Member`의 `state` 값을 확인해서 이후 로직을 수행하면 된다.

```java
// 인증 API
if (member.getState() != MemberState.DELETED) {
    // 인증 성공 ...	
}

// 암호 변경 API
if (member.getState() != MemberState.DELETED) {
    // 암호 변경 ... 	
}
```

회원의 상태가 `DELETED`인지 확인해서 요구사항을 구현하였다. 이 때 '회원의 상태가 `DELETED`인지 확인' 하는 작업처럼 수행되는 명령문을 `프로시저`라고한다. 인증 프로시저, 암호 변경 프로시저에서 모두 같은 데이터(member의 state)를 공유하여 사용했는데 이처럼 `여러 프로시저에서 데이터를 공유해서 프로그래밍하는 방식`을 `절차 지향 프로그래밍`이라고 한다.

### 변경사항에 취약한 절차 지향 프로그래밍

요구사항을 잘 구현했는데, `인증`과 `암호 변경`시 차단된 횟수 0일 때만 가능하도록 조건이 추가되었다고 한다. 이제 기존 로직을 아래와 같이 수정하자.

```java
// 인증 API
if (member.getState() != MemberState.DELETED
    && member.getBlockCount() == 0) { // 👈 조건 추가
    // 인증 성공 ...	
}

// 암호 변경 API
if (member.getState() != MemberState.DELETED
    && member.getBlockCount() == 0) { // 👈 조건 추가
    // 암호 변경 ... 	
}
```

**조건은 하나만 추가되었을 뿐인데 코드는 두 군데를 수정했다.** 그 원인은 **여러 프로시저에서 같은 데이터를 공유해서 사용했기 때문**이다. (이번에 공유된 데이터는 member의 state와 blockCount 이다.) 요구사항은 언제든지 변경될 수 있고, 그때마다 이렇게 인증 API와 암호 변경 API 로직을 수행 하기 위해 회원의 권한을 확인하는 코드가 있는 곳 전부를 변경해야 할 것이다. 이는 굉장히 수고스러울 뿐만 아니라, 혹여 개발자가 깜박하고 한 군데라도 덜 수정하게 된다면 로직은 미완성인 상태로 추가적인 문제를 야기하게 될 것이다. 다행히도 이 같은 문제는 ***`데이터`와 `프로시저`를 객체 단위로 묶음으로써 해결***할 수 있다. 

### 데이터와 프로시저를 객체 단위로 묶는다‼️

```java
// 회원 클래스
class Member {

    private MemberState state;
    private int blockCount;
	
    // ...
    
    public boolean hasPermission() { // 👈 권한을 확인하는 프로시저를 데이터와 묶는다.
        return this.state != MemberState.DELETED
            && this.blockCount != 0;
    }
	
    // ...
}
```
```java
// 인증 API
if (member.hasPermission()) { // 👈 권한이 있는지 member한테 물어본다.
    // 인증 성공 ...	
}

// 암호 변경 API
if (member.hasPermission()) { // 👈 권한이 있는지 member한테 물어본다.
    // 암호 변경 ... 	
}
```

데이터 `state`와 `blockCount` 를 사용하여 권한을 확인하는 프로시저를 메소드로 만들고, 이를 Member 클래스 안에 밀어 넣었다. 다시 말해 `데이터`와 `데이터를 사용하는 프로시저`를 `객체`단위로 묶은 것이다. 그리고 이 프로시저를 사용할 때는    

`Member 너 (인증과 암호변경을 하기위한) 권한을 갖고 있어?(=member.hasPermission())`

처럼 메소드를 호출함으로써 사용한다. 이제 요구사항이 변경되더라도 `Member::hasPermission` 만 수정하면 되므로 여러 군데를 수정할 필요가 없어지게 된다.

이렇게 **`데이터`와 데이터에 접근하는 `프로시저`를 객체 단위로 묶고, 객체끼리는 메소드를 호출함으로써 해당 프로시저를 실행시키는 방식으로 프로그래밍 하는 것**을 `객체 지향 프로그래밍` 이라고 하며, 객체 지향적으로 개발함으로써 변경 사항에 유지보수하기 쉬운 코드를 작성할 수 있게 되는 것이다. 그렇다면 이제 `객체`가 무엇인지에 대해서도 살펴볼 필요가 있겠다.  

## 객체란 무엇인가

> _**"객체란 식별 가능한 개체 또는 사물이다. 객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있따. 객체는 구별 가능한 `식별자`, `특징적인 행동`, `변경 가능한 상태`를 가진다. 소프트웨어 안에서 객체는 `저장된 상태`와 `실행 가능한 코드`를 통해 구현된다."**_ - 객체 지향의 사실과 오해 中(p.47)

객체란 

물리적인 관점으로 메모리의 Heap 영역에 할당된  


# 객체 지향의 특징 4가지

## 1. 캡슐화

결국 캡슐화는

그럼 Java에서는 이 캡슐화를 지킬 수 있게 지원하는가? 바로 `접근 제어자`가 그 역할을 한다. 

## 2. 상속

자바가 기능적으로 제공하는 extends 와는 개념이 조금 다르다. 

## 3. 추상화

공통된 부분을 뽑아내는 것이다. 

## 4. 다형성

즉 상위 클래스의 타입으로 하위 클래스의 객체를 다루는 것을 말한다. 

# 요약

- 객체지향 프로그래밍이란 데이터와 데이터와 관련된
- 기능을 묶고 해당 데이터
- 해당 데이터를 조작하거나 
- 조작이나 확인 '해달라고' 요청만 하면 될 뿐이며, 어떻게 요청을 처리할지는 해당 객체의 자율이다.

---

**※ Reference**

- [[인프런] 최범균 - 객체지향 프로그래밍 입문](https://www.inflearn.com/course/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%85%EB%AC%B8)
- [조영호 - 객체지향의 사실과 오해](http://www.yes24.com/Product/Goods/18249021)